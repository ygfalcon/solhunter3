import json
import logging
from dataclasses import dataclass
from .http import loads
import os
from pathlib import Path
import aiofiles
from solders.keypair import Keypair
from bip_utils import Bip39SeedGenerator, Bip44, Bip44Coins, Bip44Changes
import base64
import hashlib
from cryptography.fernet import Fernet, InvalidToken
from .paths import ROOT

# Older versions of ``solders`` do not expose ``to_bytes`` which our tests rely
# on. Provide a backwards compatible shim.
if not hasattr(Keypair, "to_bytes"):

    def _to_bytes(self) -> bytes:  # pragma: no cover - shim for old versions
        return bytes(self.to_bytes_array())

    Keypair.to_bytes = _to_bytes  # type: ignore[attr-defined]


if not hasattr(Keypair, "to_bytes_array"):

    def _to_bytes_array(self) -> list[int]:  # pragma: no cover
        return list(self.to_bytes())  # shim for old versions

    Keypair.to_bytes_array = _to_bytes_array  # type: ignore[attr-defined]


_keypair_dir = os.getenv("KEYPAIR_DIR", "keypairs")
if not os.path.isabs(_keypair_dir):
    KEYPAIR_DIR = str(ROOT / _keypair_dir)
else:
    KEYPAIR_DIR = _keypair_dir
ACTIVE_KEYPAIR_FILE = os.path.join(KEYPAIR_DIR, "active")
os.makedirs(KEYPAIR_DIR, exist_ok=True)

logger = logging.getLogger(__name__)


@dataclass
class KeypairInfo:
    """Structured result from :func:`setup_default_keypair`.

    The structure is intentionally simple so it can be serialized for
    accessibility tools or automation."""

    name: str
    mnemonic_path: Path | None

    def to_dict(self) -> dict[str, str | None]:
        """Return a JSON serializable representation."""
        return {
            "name": self.name,
            "mnemonic_path": (
                str(self.mnemonic_path) if self.mnemonic_path else None
            ),
        }


def _validate_keypair_data(data: object) -> bytes:
    """Validate JSON keypair data and return the secret bytes.

    The keypair must be a list of exactly 64 integers where each integer is in
    the range 0-255.  A :class:`ValueError` is raised if the input does not meet
    these requirements.
    """
    if not isinstance(data, list):
        raise ValueError("Keypair JSON must be a list")
    if len(data) != 64:
        raise ValueError("Keypair JSON must contain 64 integers")
    if any(not isinstance(i, int) or not 0 <= i <= 255 for i in data):
        raise ValueError(
            "Keypair JSON must contain only integers between 0 and 255"
        )
    return bytes(data)


def load_keypair(path: str) -> Keypair:
    """Load a Solana ``Keypair`` from a JSON file generated by
    ``solana-keygen``.

    Parameters
    ----------
    path:
        Path to the keypair JSON file. It should contain an array of integers.
    """
    with open(path, "r") as f:
        data = json.load(f)
    secret = _validate_keypair_data(data)
    return Keypair.from_bytes(secret)


async def load_keypair_async(path: str) -> Keypair:
    """Asynchronously load a Solana ``Keypair`` from ``path``."""
    async with aiofiles.open(path, "r") as f:
        content = await f.read()
    data = loads(content)
    secret = _validate_keypair_data(data)
    return Keypair.from_bytes(secret)


def list_keypairs() -> list[str]:
    """Return the names of all saved keypairs."""
    return [
        f[:-5]
        for f in os.listdir(KEYPAIR_DIR)
        if f.endswith(".json") and os.path.isfile(os.path.join(KEYPAIR_DIR, f))
    ]


def save_keypair(name: str, data: list[int]) -> None:
    """Persist a keypair under ``name``.

    The name must not contain path traversal components.
    """
    if (
        os.path.sep in name
        or (os.path.altsep and os.path.altsep in name)
        or ".." in name
    ):
        raise ValueError("invalid keypair name")
    path = os.path.join(KEYPAIR_DIR, name + ".json")
    tmp_path = path + ".tmp"
    fd = os.open(tmp_path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o600)
    try:
        with os.fdopen(fd, "w", encoding="utf-8") as f:
            json.dump(data, f)
        os.replace(tmp_path, path)
        os.chmod(path, 0o600)
    except Exception:
        try:
            os.unlink(tmp_path)
        except FileNotFoundError:
            pass
        raise


def select_keypair(name: str) -> None:
    """Mark the named keypair as active."""
    path = os.path.join(KEYPAIR_DIR, name + ".json")
    if not os.path.exists(path):
        raise FileNotFoundError(path)
    with open(ACTIVE_KEYPAIR_FILE, "w", encoding="utf-8") as f:
        f.write(name)


def get_active_keypair_name() -> str | None:
    try:
        with open(ACTIVE_KEYPAIR_FILE, "r", encoding="utf-8") as f:
            return f.read().strip() or None
    except FileNotFoundError:
        return None


def load_selected_keypair() -> Keypair | None:
    name = get_active_keypair_name()
    if not name:
        return None
    path = os.path.join(KEYPAIR_DIR, name + ".json")
    return load_keypair(path)


async def load_selected_keypair_async() -> Keypair | None:
    name = get_active_keypair_name()
    if not name:
        return None
    path = os.path.join(KEYPAIR_DIR, name + ".json")
    return await load_keypair_async(path)


def load_keypair_from_mnemonic(mnemonic: str, passphrase: str = "") -> Keypair:
    """Derive a Solana ``Keypair`` from a BIP-39 mnemonic.

    The key is derived from the standard path ``m/44'/501'/0'/0'``.
    This matches the behavior of ``solana-keygen recover``.

    Parameters
    ----------
    mnemonic:
        Space separated seed words.
    passphrase:
        Optional passphrase for the seed.
    """

    seed = Bip39SeedGenerator(mnemonic).Generate(passphrase)
    secret = (
        Bip44.FromSeed(seed, Bip44Coins.SOLANA)
        .Purpose()
        .Coin()
        .Account(0)
        .Change(Bip44Changes.CHAIN_EXT)
        .AddressIndex(0)
        .PrivateKey()
        .Raw()
        .ToBytes()
    )
    return Keypair.from_seed(secret)


def _derive_key(password: str, salt: bytes) -> bytes:
    """Derive a Fernet-compatible key from ``password`` and ``salt``."""

    kdf = hashlib.pbkdf2_hmac(
        "sha256", password.encode("utf-8"), salt, 390000, dklen=32
    )
    return base64.urlsafe_b64encode(kdf)


def _encrypt_mnemonic(text: str, password: str) -> str:
    """Encrypt ``text`` using a password.

    A random salt is generated and prepended to the token so that the decrypt
    function can derive the correct key.  The final value is a base64 encoded
    string suitable for storage.
    """

    salt = os.urandom(16)
    key = _derive_key(password, salt)
    token = Fernet(key).encrypt(text.encode("utf-8"))
    return base64.urlsafe_b64encode(salt + token).decode("utf-8")


def _decrypt_mnemonic(token: str, password: str) -> str:
    """Decrypt a token previously returned by :func:`_encrypt_mnemonic`."""

    try:
        data = base64.urlsafe_b64decode(token.encode("utf-8"))
    except Exception as exc:  # pragma: no cover - invalid base64
        raise ValueError("invalid token") from exc
    if len(data) < 17:  # 16 byte salt + at least 1 byte of data
        raise ValueError("invalid token")
    salt, ftoken = data[:16], data[16:]
    key = _derive_key(password, salt)
    try:
        dec = Fernet(key).decrypt(ftoken)
    except InvalidToken as exc:
        raise ValueError("invalid token") from exc
    return dec.decode("utf-8")


def generate_default_keypair(*, encrypt: bool | None = None) -> tuple[str, Path]:
    """Generate and persist a default keypair derived from a mnemonic.

    The mnemonic is either taken from the ``MNEMONIC`` environment variable or
    a new 24-word phrase is generated.  The derived keypair is saved as
    ``default.json`` within :data:`KEYPAIR_DIR` and selected as the active
    keypair.  The mnemonic is written to ``default.mnemonic`` with permissions
    ``600`` so only the current user can read it. When ``encrypt`` is enabled
    the mnemonic is stored in an encrypted form using
    ``MNEMONIC_ENCRYPTION_KEY`` as the passphrase or ``ENCRYPT_MNEMONIC``
    environment variable.

    Returns
    -------
    tuple[str, Path]
        The mnemonic and the path to the stored mnemonic file.
    """

    try:  # ``bip_utils`` is optional during tests
        from bip_utils import Bip39MnemonicGenerator  # type: ignore
    except Exception:  # pragma: no cover - fallback for stubbed module
        Bip39MnemonicGenerator = None  # type: ignore

    mnemonic = os.environ.get("MNEMONIC")
    if not mnemonic:
        if Bip39MnemonicGenerator:
            mnemonic = str(Bip39MnemonicGenerator().FromWordsNumber(24))
        else:  # pragma: no cover - simple fallback for stubs
            mnemonic = "abandon " * 23 + "abandon"

    passphrase = os.environ.get("PASSPHRASE", "")
    kp = load_keypair_from_mnemonic(mnemonic, passphrase)
    save_keypair("default", list(kp.to_bytes()))
    select_keypair("default")
    os.environ.setdefault("MNEMONIC", mnemonic)

    if encrypt is None:
        encrypt = os.getenv("ENCRYPT_MNEMONIC") == "1"
    enc_pass = os.getenv("MNEMONIC_ENCRYPTION_KEY", "")

    mnemonic_path = Path(KEYPAIR_DIR) / "default.mnemonic"
    mnemonic_path.parent.mkdir(parents=True, exist_ok=True)
    fd = os.open(mnemonic_path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o600)
    with os.fdopen(fd, "w", encoding="utf-8") as f:
        if encrypt:
            if not enc_pass:
                raise ValueError(
                    "MNEMONIC_ENCRYPTION_KEY must be set when ENCRYPT_MNEMONIC=1"
                )
            f.write(_encrypt_mnemonic(mnemonic, enc_pass) + "\n")
        else:
            f.write(mnemonic + "\n")

    return mnemonic, mnemonic_path


def ensure_default_keypair() -> KeypairInfo:
    """Ensure a default keypair is available and selected.

    When no active keypair exists a new one is generated via
    :func:`generate_default_keypair` and selected as ``default``.
    The mnemonic path is included in the return value to aid automation.
    """

    active = get_active_keypair_name()
    if active:
        return KeypairInfo(active, None)

    mnemonic, mnemonic_path = generate_default_keypair()
    name = "default"
    logger.info(
        "Generated keypair '%s'. Mnemonic stored at %s.",
        name,
        mnemonic_path,
    )
    return KeypairInfo(name, mnemonic_path)


def setup_default_keypair() -> KeypairInfo:
    """Ensure a usable keypair exists and is selected.

    When no keypairs are present a new one is derived from a mnemonic using
    :func:`generate_default_keypair`. The mnemonic path is only returned when a
    new keypair is generated. If multiple keypairs exist and none are active
    the user is prompted to select one unless ``AUTO_SELECT_KEYPAIR`` is ``1``
    or standard input is not a TTY.

    Returns
    -------
    KeypairInfo
        Structured data describing the active keypair.
    """

    import json
    import shutil
    import subprocess
    import sys

    keypair_json = os.environ.get("KEYPAIR_JSON")
    if not list_keypairs() and not keypair_json:
        try:
            from scripts import quick_setup

            quick_setup.main(["--auto", "--non-interactive"])
        except Exception as exc:
            logger.warning("quick setup failed: %s", exc)

    active = get_active_keypair_name()
    if active:
        return KeypairInfo(active, None)

    keypairs = list_keypairs()
    if keypairs:
        keypairs.sort()
        choice = keypairs[0]
        if (
            len(keypairs) > 1
            and sys.stdin.isatty()
            and os.getenv("AUTO_SELECT_KEYPAIR") != "1"
        ):
            print("Available keypairs:")
            for idx, name in enumerate(keypairs, 1):
                print(f"{idx}. {name}")
            sel = input("Select keypair [1]: ").strip()
            if sel:
                try:
                    i = int(sel) - 1
                    if 0 <= i < len(keypairs):
                        choice = keypairs[i]
                    else:
                        logger.warning(
                            "selected keypair index %s out of range", sel
                        )
                except Exception as exc:
                    logger.warning("invalid keypair selection %s: %s", sel, exc)
        select_keypair(choice)
        return KeypairInfo(choice, None)

    if keypair_json:
        try:
            data = json.loads(keypair_json)
            if isinstance(data, list):
                save_keypair("default", data)
            else:
                raise ValueError
        except Exception:
            cmd = ["solhunter-wallet", "save", "default", keypair_json]
            if shutil.which("solhunter-wallet") is None:
                cmd = [
                    sys.executable,
                    "-m",
                    "solhunter_zero.wallet_cli",
                    "save",
                    "default",
                    keypair_json,
                ]
            subprocess.check_call(cmd)
        select_keypair("default")
        return KeypairInfo("default", None)

    mnemonic, mnemonic_path = generate_default_keypair()
    return KeypairInfo("default", mnemonic_path)
