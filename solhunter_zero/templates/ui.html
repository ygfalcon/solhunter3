<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SolHunter · Live Console</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #05070e;
      --surface: rgba(11, 15, 26, 0.96);
      --surface-strong: rgba(18, 24, 39, 0.96);
      --border: rgba(70, 130, 255, 0.28);
      --border-strong: rgba(70, 130, 255, 0.45);
      --text: #f3f6ff;
      --muted: #8a94ad;
      --accent: #4b82ff;
      --success: #37d67a;
      --warning: #f5a524;
      --danger: #ff4f5e;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, rgba(75, 130, 255, 0.22), transparent 55%), var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }
    header {
      position: sticky;
      top: 0;
      z-index: 20;
      padding: 20px clamp(16px, 3vw, 32px) 18px;
      background: linear-gradient(90deg, rgba(10, 15, 25, 0.95), rgba(10, 15, 25, 0.82));
      border-bottom: 1px solid var(--border-strong);
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.42);
      backdrop-filter: blur(18px);
    }
    .header-top {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 18px;
      align-items: center;
      justify-content: space-between;
    }
    .header-top h1 {
      margin: 0;
      font-size: 1.35rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    .pills {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 999px;
      border: 1px solid var(--border-strong);
      background: rgba(18, 24, 39, 0.72);
      font-size: 0.8rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    .pill.success { border-color: rgba(55, 214, 122, 0.65); background: rgba(55, 214, 122, 0.18); }
    .pill.warning { border-color: rgba(245, 165, 36, 0.65); background: rgba(245, 165, 36, 0.18); }
    .pill.danger { border-color: rgba(255, 79, 94, 0.65); background: rgba(255, 79, 94, 0.18); }
    .header-grid {
      margin-top: 18px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }
    .header-card {
      padding: 12px 16px;
      border-radius: 14px;
      background: var(--surface);
      border: 1px solid var(--border);
      display: grid;
      gap: 6px;
    }
    .header-card dt {
      margin: 0;
      font-size: 0.72rem;
      color: var(--muted);
      letter-spacing: 0.07em;
      text-transform: uppercase;
    }
    .header-card dd {
      margin: 0;
      font-size: 0.98rem;
      font-weight: 600;
      word-break: break-all;
    }
    .header-actions {
      margin-top: 16px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    button, select {
      font: inherit;
    }
    .ghost-btn {
      padding: 8px 14px;
      border-radius: 12px;
      border: 1px solid var(--border-strong);
      background: rgba(16, 22, 36, 0.85);
      color: var(--text);
      cursor: pointer;
      transition: background 0.2s ease, border 0.2s ease;
    }
    .ghost-btn:hover { background: rgba(21, 28, 44, 0.95); border-color: var(--accent); }
    .ghost-btn[disabled] { opacity: 0.6; cursor: not-allowed; }
    main {
      flex: 1;
      padding: 28px clamp(16px, 3vw, 32px) 48px;
    }
    .console-grid {
      display: grid;
      gap: 24px;
      grid-template-columns: 320px minmax(360px, 1.7fr) minmax(320px, 1.1fr);
    }
    .column { display: flex; flex-direction: column; gap: 24px; }
    article.panel {
      background: var(--surface-strong);
      border-radius: 18px;
      border: 1px solid var(--border);
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      min-height: 160px;
      position: relative;
    }
    article.panel[data-rate-limited] {
      border-color: rgba(255, 79, 94, 0.65);
      box-shadow: 0 0 0 1px rgba(255, 79, 94, 0.35);
    }
    article.panel[data-rate-limited]::after {
      content: attr(data-rate-limited);
      position: absolute;
      top: 12px;
      right: 16px;
      font-size: 0.7rem;
      color: var(--danger);
      background: rgba(255, 79, 94, 0.12);
      border: 1px solid rgba(255, 79, 94, 0.4);
      border-radius: 10px;
      padding: 4px 8px;
      max-width: 60%;
      text-align: right;
    }
    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .panel-header h2 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: 0.03em;
    }
    .panel-header .controls {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }
    .panel-header .controls select,
    .panel-header .controls button {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(15, 21, 34, 0.78);
      color: var(--text);
      cursor: pointer;
    }
    .panel-body { display: flex; flex-direction: column; gap: 12px; }
    .panel-status { font-size: 0.82rem; color: var(--muted); }
    .inline-error { font-size: 0.8rem; color: #ffb3ae; }
    .numeric-up { color: var(--success); }
    .numeric-down { color: var(--danger); }
    .banner {
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 0.82rem;
    }
    .banner.warning { background: rgba(245, 165, 36, 0.18); border: 1px solid rgba(245, 165, 36, 0.45); color: #ffe2b0; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 6px 8px; text-align: left; font-size: 0.84rem; }
    thead th {
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
      border-bottom: 1px solid rgba(75, 130, 255, 0.16);
      cursor: pointer;
    }
    tbody tr:hover { background: rgba(75, 130, 255, 0.1); }
    tbody tr.empty td { text-align: center; color: var(--muted); padding: 18px 0; }
    .table-wrapper { max-height: 320px; overflow: auto; }
    .timeline, .list { display: grid; gap: 10px; max-height: 420px; overflow-y: auto; padding-right: 4px; }
    .timeline-item, .list-item {
      background: rgba(15, 21, 34, 0.92);
      border: 1px solid rgba(75, 130, 255, 0.2);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 4px;
    }
    .timeline-item.selected { border-color: var(--accent); }
    .timeline-item .meta { display: flex; justify-content: space-between; color: var(--muted); font-size: 0.72rem; }
    .sparkline { height: 60px; background: rgba(12, 18, 30, 0.92); border-radius: 10px; position: relative; }
    .sparkline canvas { position: absolute; inset: 0; }
    .badges { display: flex; gap: 6px; flex-wrap: wrap; }
    .badge { padding: 4px 8px; border-radius: 8px; background: rgba(75, 130, 255, 0.2); border: 1px solid rgba(75, 130, 255, 0.35); font-size: 0.72rem; letter-spacing: 0.05em; text-transform: uppercase; }
    .grid-two { display: grid; gap: 12px; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
    .log-line {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.8rem;
      white-space: pre-wrap;
      background: rgba(8, 12, 20, 0.95);
      border-radius: 10px;
      border: 1px solid rgba(75, 130, 255, 0.22);
      padding: 8px 10px;
    }
    .log-line.info { border-left: 3px solid var(--accent); }
    .log-line.warn { border-left: 3px solid var(--warning); }
    .log-line.error { border-left: 3px solid var(--danger); }
    .portfolio-actions { display: flex; gap: 6px; }
    .portfolio-actions button { padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(75, 130, 255, 0.4); background: rgba(16, 22, 36, 0.85); color: var(--text); cursor: pointer; }
    .portfolio-actions button[disabled] { opacity: 0.5; cursor: not-allowed; }
    a.link-out { color: var(--accent); text-decoration: none; }
    a.link-out:hover { text-decoration: underline; }
    @media (max-width: 1320px) {
      .console-grid { grid-template-columns: repeat(2, minmax(300px, 1fr)); }
    }
    @media (max-width: 900px) {
      header { position: relative; }
      .console-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="live-console" data-ui-schema="{{ ui_schema_version }}">
    <header id="run-header">
      <div class="header-top">
        <h1>Live Console</h1>
        <div class="pills">
          <span id="pill-live" class="pill">Live</span>
          <span id="pill-mode" class="pill">Mode: —</span>
          <span id="pill-workflow" class="pill">Workflow: —</span>
          <span id="pill-health" class="pill warning">Health: unknown</span>
        </div>
      </div>
      <div class="header-grid">
        <dl class="header-card"><dt>Keypair</dt><dd id="keypair-display">—</dd></dl>
        <dl class="header-card"><dt>Budget Remaining</dt><dd id="budget-remaining">—</dd></dl>
        <dl class="header-card"><dt>Risk</dt><dd id="risk-current">—</dd></dl>
        <dl class="header-card"><dt>Throttle / Backoff</dt><dd id="throttle-backoff">—</dd></dl>
        <dl class="header-card"><dt>RPS Limits</dt><dd id="rps-limits">—</dd></dl>
      </div>
      <div class="header-actions">
        <button class="ghost-btn" id="copy-env-btn">Copy env</button>
        <button class="ghost-btn" id="self-check-btn">Run Self-Check</button>
        <span id="run-stream-status" style="font-size:0.8rem;color:var(--muted);">Run state: connecting…</span>
        <span id="self-check-status" style="font-size:0.8rem;color:var(--muted);">Self-Check idle</span>
      </div>
    </header>
    <main>
      <section class="console-grid">
        <div class="column">
          <article class="panel" id="panel-discovery">
            <div class="panel-header">
              <h2>Discovery Stream (Mint &amp; Mempool)</h2>
              <div class="controls">
                <select data-control="window">
                  <option value="5">5s</option>
                  <option value="15" selected>15s</option>
                  <option value="60">60s</option>
                </select>
                <button type="button" data-control="pause">Pause</button>
              </div>
            </div>
            <div class="panel-body">
              <div class="panel-status" data-role="status">Bootstrapping…</div>
              <div class="timeline" data-role="timeline"></div>
              <div class="inline-error" data-role="error"></div>
            </div>
          </article>
          <article class="panel" id="panel-logs">
            <div class="panel-header">
              <h2>Structured Logs (Live)</h2>
              <div class="controls">
                <button type="button" data-control="pause">Pause</button>
              </div>
            </div>
            <div class="panel-body">
              <div class="panel-status" data-role="status">Connecting…</div>
              <div class="list" data-role="list"></div>
              <div class="inline-error" data-role="error"></div>
            </div>
          </article>
        </div>
        <div class="column">
          <article class="panel" id="panel-token">
            <div class="panel-header">
              <h2>Token Deep View</h2>
              <div class="controls">
                <button type="button" data-control="pause">Pause</button>
              </div>
            </div>
            <div class="panel-body">
              <div class="banner warning" data-role="invalid" hidden>Mint invalid; streams continue with caution.</div>
              <div class="panel-status" data-role="status">Pick a discovery candidate.</div>
              <div class="grid-two" data-role="meta"></div>
              <div class="sparkline"><canvas data-role="sparkline"></canvas></div>
              <div class="badges" data-role="badges"></div>
              <div class="inline-error" data-role="error"></div>
            </div>
          </article>
          <article class="panel" id="panel-agents">
            <div class="panel-header">
              <h2>Agent Swarm Timeline</h2>
              <div class="controls">
                <select data-control="window">
                  <option value="5">5s</option>
                  <option value="15">15s</option>
                  <option value="60" selected>60s</option>
                </select>
                <button type="button" data-control="pause">Pause</button>
              </div>
            </div>
            <div class="panel-body">
              <div class="panel-status" data-role="status">Waiting for mint…</div>
              <div class="timeline" data-role="timeline"></div>
              <div class="inline-error" data-role="error"></div>
            </div>
          </article>
          <article class="panel" id="panel-planner">
            <div class="panel-header">
              <h2>Trade Planner &amp; Routing</h2>
              <div class="controls">
                <button type="button" data-control="pause">Pause</button>
              </div>
            </div>
            <div class="panel-body">
              <div class="panel-status" data-role="status">Waiting for mint…</div>
              <div class="grid-two" data-role="plan"></div>
              <div class="panel-status" data-role="dry-run">Dry-run not ready.</div>
              <div class="inline-error" data-role="error"></div>
            </div>
          </article>
        </div>
        <div class="column">
          <article class="panel" id="panel-orders">
            <div class="panel-header">
              <h2>Orders, Fills &amp; Slippage</h2>
              <div class="controls">
                <select data-control="window">
                  <option value="5">5s</option>
                  <option value="15">15s</option>
                  <option value="60" selected>60s</option>
                  <option value="0">All</option>
                </select>
                <button type="button" data-control="pause">Pause</button>
              </div>
            </div>
            <div class="panel-body">
              <div class="panel-status" data-role="status">Loading…</div>
              <div class="table-wrapper">
                <table>
                  <thead>
                    <tr>
                      <th data-sort="ts">Time</th>
                      <th data-sort="mint">Mint</th>
                      <th data-sort="side">Side</th>
                      <th data-sort="qty">Qty</th>
                      <th data-sort="route">Route</th>
                      <th data-sort="price">Quote → Fill</th>
                      <th data-sort="slippage">Slippage (bps)</th>
                      <th data-sort="fees">Fees</th>
                      <th data-sort="status">Status</th>
                    </tr>
                  </thead>
                  <tbody data-role="rows"></tbody>
                </table>
              </div>
              <div class="panel-status" data-role="summary">—</div>
              <div class="inline-error" data-role="error"></div>
            </div>
          </article>
          <article class="panel" id="panel-positions">
            <div class="panel-header">
              <h2>Positions &amp; Portfolio</h2>
              <div class="controls">
                <button type="button" data-control="pause">Pause</button>
              </div>
            </div>
            <div class="panel-body">
              <div class="panel-status" data-role="status">Loading…</div>
              <div class="table-wrapper">
                <table>
                  <thead>
                    <tr>
                      <th data-sort="mint">Mint</th>
                      <th data-sort="qty">Qty</th>
                      <th data-sort="avg_cost">Avg Cost</th>
                      <th data-sort="mark">Mark</th>
                      <th data-sort="ue_pnl">UE PnL</th>
                      <th data-sort="realized_pnl">Realized PnL</th>
                      <th data-sort="risk">Risk Wt</th>
                      <th>Actions</th>
                    </tr>
                  </thead>
                  <tbody data-role="rows"></tbody>
                </table>
              </div>
              <div class="panel-status" data-role="budget">Budget widget pending…</div>
              <div class="inline-error" data-role="error"></div>
            </div>
          </article>
          <article class="panel" id="panel-pnl">
            <div class="panel-header">
              <h2>PnL &amp; Risk Overview</h2>
              <div class="controls">
                <select data-control="window">
                  <option value="3600">1h</option>
                  <option value="86400" selected>24h</option>
                </select>
                <button type="button" data-control="pause">Pause</button>
              </div>
            </div>
            <div class="panel-body">
              <div class="panel-status" data-role="status">Loading…</div>
              <div class="grid-two" data-role="metrics"></div>
              <div class="inline-error" data-role="error"></div>
            </div>
          </article>
          <article class="panel" id="panel-runtime">
            <div class="panel-header">
              <h2>Runtime Health &amp; Rate Limits</h2>
              <div class="controls">
                <button type="button" data-control="pause">Pause</button>
              </div>
            </div>
            <div class="panel-body">
              <div class="panel-status" data-role="status">Loading…</div>
              <div class="grid-two" data-role="metrics"></div>
              <div class="inline-error" data-role="error"></div>
            </div>
          </article>
        </div>
      </section>
    </main>
<script>
(function() {
  'use strict';
  const UI_READY_MESSAGE = 'UI ready: 10/10 panels wired, no dead panels';
  const RL_EVENT_BUS = 'ws://127.0.0.1:8779';
  const EVENT_CHANNEL = 'solhunter-events-v3';
  const doc = document;
  const ENDPOINTS = {
    runStateSnapshot: '/api/run/state',
    runStateStream: '/ws/run/state',
    runEnv: '/api/run/env',
    uiMeta: '/api/ui/meta',
    health: '/api/health',
    discoverySnapshot: '/api/discovery/recent?limit=200',
    discoveryStream: '/ws/discovery',
    tokenMeta: (mint) => `/api/token/${encodeURIComponent(mint)}`,
    tokenMetaResolver: (mint) => `/api/token/meta/${encodeURIComponent(mint)}`,
    tokenPrice: (mint) => `/api/price/${encodeURIComponent(mint)}`,
    tokenPriceStream: (mint) => `/ws/price/${encodeURIComponent(mint)}`,
    tokenDepthStream: (mint) => `/ws/depth/${encodeURIComponent(mint)}`,
    agentEventsBackfill: (mint, since) => `/api/agents/events?mint=${encodeURIComponent(mint)}&since=${encodeURIComponent(since)}`,
    agentEventsStream: (mint) => {
      const base = '/ws/agents/events';
      return mint ? `${base}?mint=${encodeURIComponent(mint)}` : base;
    },
    executionPlanSnapshot: (mint) => `/api/execution/plan?mint=${encodeURIComponent(mint)}`,
    executionPlanStream: (mint) => {
      const base = '/ws/execution/plan';
      return mint ? `${base}?mint=${encodeURIComponent(mint)}` : base;
    },
    fillsSnapshot: '/api/execution/fills?limit=500',
    fillsStream: '/ws/execution/fills',
    closePosition: (mint, qty) => `/api/execution/close?mint=${encodeURIComponent(mint)}&qty=${encodeURIComponent(qty)}`,
    positionsSnapshot: '/api/portfolio/positions',
    portfolioStream: '/ws/portfolio',
    pnlSnapshot: (window) => `/api/portfolio/pnl?window=${window}`,
    riskSnapshot: '/api/risk/state',
    riskStream: '/ws/risk',
    providerStatus: '/api/providers/status',
    metricsStream: '/ws/metrics',
    logsSnapshot: (runId) => {
      const base = '/api/logs/tail?lines=500';
      return runId ? `${base}&run_id=${encodeURIComponent(runId)}` : base;
    },
    logsStream: (runId) => {
      const base = '/ws/logs?level=INFO|WARN|ERROR';
      return runId ? `${base}&run_id=${encodeURIComponent(runId)}` : base;
    }
  };
  const hydration = {
    runHeader: false,
    discovery: false,
    token: false,
    agents: false,
    planner: false,
    orders: false,
    positions: false,
    pnl: false,
    runtime: false,
    logs: false
  };
  const RATE_LIMIT_PANEL_MAP = [
    {pattern: /helius/i, panels: ['panel-token', 'panel-planner']},
    {pattern: /(das|amm|mint)/i, panels: ['panel-discovery']},
    {pattern: /(portfolio|position|risk)/i, panels: ['panel-positions', 'panel-pnl']},
    {pattern: /(execution|order|router|jito)/i, panels: ['panel-orders', 'panel-planner']},
    {pattern: /(log|event|redis|queue)/i, panels: ['panel-logs']}
  ];
  const state = {
    selectedMint: null,
    runState: null,
    rlHealthUrl: null,
    keypairPath: null,
    discoveryWindow: 15,
    discoveryPaused: false,
    discoveryEvents: [],
    tokenPaused: false,
    agentWindow: 60,
    agentPaused: false,
    plannerPaused: false,
    ordersWindow: 60,
    ordersPaused: false,
    orders: [],
    positionsPaused: false,
    pnlWindow: 86400,
    pnlPaused: false,
    runtimePaused: false,
    logsPaused: false,
    planByMint: new Map(),
    lastRiskState: null,
    pnlMetrics: null,
    runtimeMetrics: null,
    priceSnapshots: new Map(),
    depthByMint: new Map(),
    rateLimitAnnotations: new Map()
  };
  function createStore(initial) {
    let value = initial;
    const listeners = new Set();
    return {
      get() { return value; },
      set(next) {
        if (value === next) return;
        value = next;
        listeners.forEach((listener) => {
          try { listener(next); } catch (err) { console.error('store listener failed', err); }
        });
      },
      subscribe(listener) {
        listeners.add(listener);
        return () => listeners.delete(listener);
      }
    };
  }
    const selectedMintStore = createStore(null);
    const originalSelectedMintSet = selectedMintStore.set.bind(selectedMintStore);
    selectedMintStore.set = function(next) {
      state.selectedMint = next;
      originalSelectedMintSet(next);
    };
  function safeJsonParse(text, panelId, errorNode) {
    try {
      return JSON.parse(text);
    } catch (err) {
      if (errorNode) {
        errorNode.textContent = `Deserialization error (${panelId}): ${err && err.message ? err.message : err}`;
      }
      throw err;
    }
  }
  async function safeFetchJson(url, panelId, errorNode, options) {
    try {
      const response = await fetch(url, options);
      if (!response.ok) {
        const detail = `${response.status} ${response.statusText}`;
        if (errorNode) {
          errorNode.textContent = `${panelId} request failed: ${detail}`;
        }
        throw new Error(detail);
      }
      const text = await response.text();
      if (!text) {
        if (errorNode) errorNode.textContent = '';
        return null;
      }
      const parsed = safeJsonParse(text, panelId, errorNode);
      if (errorNode) errorNode.textContent = '';
      return parsed;
    } catch (err) {
      if (errorNode && !errorNode.textContent) {
        errorNode.textContent = `${panelId} request error: ${err && err.message ? err.message : err}`;
      }
      throw err;
    }
  }
  function formatNumber(value, digits = 2) {
    if (value === undefined || value === null || Number.isNaN(Number(value))) return '—';
    const num = Number(value);
    if (Math.abs(num) >= 1000) {
      return num.toLocaleString(undefined, {maximumFractionDigits: digits});
    }
    return num.toFixed(digits);
  }
  function formatCurrency(value) {
    if (value === undefined || value === null || Number.isNaN(Number(value))) return '—';
    return Number(value).toLocaleString(undefined, {style: 'currency', currency: 'USD', maximumFractionDigits: 2});
  }
  function formatPercent(value) {
    if (value === undefined || value === null || Number.isNaN(Number(value))) return '—';
    return `${Number(value).toFixed(2)}%`;
  }
  function toMillis(ts) {
    if (!ts && ts !== 0) return Date.now();
    if (typeof ts === 'number') {
      return ts < 2_000_000_000 ? ts * 1000 : ts;
    }
    const parsed = Date.parse(ts);
    return Number.isNaN(parsed) ? Date.now() : parsed;
  }
  function formatTimestamp(ts) {
    const ms = toMillis(ts);
    const date = new Date(ms);
    if (Number.isNaN(date.getTime())) return '—';
    return {
      label: date.toLocaleString(undefined, {hour12: false}),
      utc: date.toISOString()
    };
  }
  function maybeNumber(value) {
    if (value === undefined || value === null || value === '') return null;
    const num = Number(value);
    return Number.isFinite(num) ? num : null;
  }
  function updatePriceSnapshot(mint, payload) {
    if (!mint || !payload || typeof payload !== 'object') return;
    const snapshot = state.priceSnapshots.get(mint) || {};
    const assignments = [
      ['price', payload.price ?? payload.px ?? payload.last],
      ['mark', payload.mark ?? payload.mark_price],
      ['mid', payload.mid ?? payload.mid_price],
      ['reference', payload.reference_price ?? payload.target_price]
    ];
    assignments.forEach(([key, value]) => {
      const num = maybeNumber(value);
      if (num !== null) {
        snapshot[key] = num;
      }
    });
    if (snapshot.price !== undefined && snapshot.mark === undefined) {
      snapshot.mark = snapshot.price;
    }
    const origin = typeof payload.__source === 'string' ? payload.__source : 'stream';
    state.priceSnapshots.set(mint, snapshot);
    doc.dispatchEvent(new CustomEvent('price-snapshot-update', {detail: {mint, snapshot, origin}}));
  }
  function normalizeOrderbookPayload(payload) {
    if (!payload || typeof payload !== 'object') return null;
    const source = payload.orderbook || payload.book || payload.depth || payload;
    const toPairs = (levels) => {
      if (!Array.isArray(levels)) return [];
      return levels
        .map((level) => {
          if (Array.isArray(level)) {
            const price = maybeNumber(level[0]);
            const size = maybeNumber(level[1]);
            return price !== null && size !== null && size > 0 ? [price, size] : null;
          }
          if (level && typeof level === 'object') {
            const price = maybeNumber(level.price ?? level.px ?? level[0]);
            const size = maybeNumber(level.size ?? level.qty ?? level.quantity ?? level.amount ?? level[1]);
            return price !== null && size !== null && size > 0 ? [price, size] : null;
          }
          return null;
        })
        .filter(Boolean);
    };
    const bids = toPairs(source.bids || source.bid || source.buy || []);
    const asks = toPairs(source.asks || source.ask || source.sell || []);
    if (!bids.length && !asks.length) return null;
    const ts = toMillis(source.ts || source.timestamp || payload.ts || payload.timestamp || Date.now());
    return {bids, asks, ts};
  }
  function resolvePanelsForMetric(metricKey) {
    const panels = new Set(['panel-runtime']);
    RATE_LIMIT_PANEL_MAP.forEach(({pattern, panels: mapped}) => {
      if (pattern.test(metricKey)) {
        mapped.forEach((panelId) => panels.add(panelId));
      }
    });
    return Array.from(panels);
  }
  function applyRateLimitAnnotations(annotationMap) {
    const applied = new Set();
    annotationMap.forEach((messages, panelId) => {
      const panel = doc.getElementById(panelId);
      if (!panel) return;
      const uniqueMessages = Array.from(new Set(messages));
      panel.setAttribute('data-rate-limited', `Rate limited: ${uniqueMessages.join(', ')}`);
      applied.add(panelId);
    });
    state.rateLimitAnnotations.forEach((_, panelId) => {
      if (!applied.has(panelId)) {
        const panel = doc.getElementById(panelId);
        if (panel) panel.removeAttribute('data-rate-limited');
      }
    });
    state.rateLimitAnnotations = new Map(annotationMap);
  }
  function annotateRateLimitPanels(metrics) {
    if (!metrics || typeof metrics !== 'object') {
      applyRateLimitAnnotations(new Map());
      return;
    }
    const annotations = new Map();
    Object.entries(metrics).forEach(([key, value]) => {
      const numeric = maybeNumber(value);
      if (numeric === null || numeric <= 0) return;
      const normalizedKey = key.toLowerCase();
      if (!normalizedKey.includes('429') && !normalizedKey.includes('rate_limit')) return;
      resolvePanelsForMetric(normalizedKey).forEach((panelId) => {
        const list = annotations.get(panelId) || [];
        list.push(key);
        annotations.set(panelId, list);
      });
    });
    applyRateLimitAnnotations(annotations);
  }
  function extractPlanSize(plan) {
    if (!plan || typeof plan !== 'object') return null;
    const candidates = [plan.size, plan.quantity, plan.qty, plan.base_size, plan.amount, plan.notional];
    for (const value of candidates) {
      const num = maybeNumber(value);
      if (num !== null && num > 0) return num;
    }
    return null;
  }
  function getReferencePrice(mint, plan) {
    const candidates = [];
    if (plan && typeof plan === 'object') {
      candidates.push(plan.reference_price, plan.mark_price, plan.mark, plan.mid_price, plan.price, plan.quote_price);
    }
    const snapshot = state.priceSnapshots.get(mint);
    if (snapshot) {
      candidates.push(snapshot.mid, snapshot.mark, snapshot.price, snapshot.reference);
    }
    for (const value of candidates) {
      const num = maybeNumber(value);
      if (num !== null && num > 0) return num;
    }
    return null;
  }
  function simulatePlanFill(mint, plan) {
    const book = state.depthByMint.get(mint);
    if (!book) return null;
    const rawIntent = (plan.intent || plan.action || plan.side || '').toString().toLowerCase();
    const isSell = rawIntent.includes('sell');
    const isBuy = rawIntent.includes('buy');
    if (!isSell && !isBuy) return null;
    const size = extractPlanSize(plan);
    if (size === null) return null;
    const levels = isSell ? book.bids : book.asks;
    if (!Array.isArray(levels) || !levels.length) return null;
    let remaining = size;
    let notional = 0;
    let filled = 0;
    for (const [price, qty] of levels) {
      if (remaining <= 0) break;
      const levelPrice = maybeNumber(price);
      const levelQty = maybeNumber(qty);
      if (levelPrice === null || levelQty === null || levelQty <= 0) continue;
      const take = Math.min(remaining, levelQty);
      notional += take * levelPrice;
      filled += take;
      remaining -= take;
    }
    if (filled <= 0) return null;
    const avgPrice = notional / filled;
    const reference = getReferencePrice(mint, plan);
    const impactPct = reference ? ((avgPrice - reference) / reference) * 100 : null;
    return {avgPrice, filled, remaining, impactPct, side: isSell ? 'sell' : 'buy', ts: book.ts};
  }
  function setHealthPill(status, message) {
    const pill = doc.getElementById('pill-health');
    if (!pill) return;
    pill.classList.remove('success', 'warning', 'danger');
    pill.textContent = `Health: ${message || status}`;
    if (status === 'green') {
      pill.classList.add('success');
    } else if (status === 'red') {
      pill.classList.add('danger');
    } else {
      pill.classList.add('warning');
    }
  }
  function setLivePill(canary) {
    const pill = doc.getElementById('pill-live');
    if (!pill) return;
    pill.textContent = canary ? 'Live (Canary)' : 'Live';
  }
  function copyToClipboard(text) {
    if (!navigator.clipboard) {
      const textarea = doc.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      doc.body.appendChild(textarea);
      textarea.focus();
      textarea.select();
      try { doc.execCommand('copy'); } catch (err) { console.error('copy failed', err); }
      doc.body.removeChild(textarea);
      return;
    }
    navigator.clipboard.writeText(text).catch((err) => console.error('copy failed', err));
  }
  function resolveWsUrl(rawUrl) {
    if (!rawUrl || typeof rawUrl !== 'string') return rawUrl;
    if (rawUrl.startsWith('ws://') || rawUrl.startsWith('wss://')) {
      return rawUrl;
    }
    try {
      if (rawUrl.startsWith('http://') || rawUrl.startsWith('https://')) {
        const parsed = new URL(rawUrl);
        parsed.protocol = parsed.protocol === 'https:' ? 'wss:' : 'ws:';
        return parsed.toString();
      }
      const resolved = new URL(rawUrl, window.location.href);
      resolved.protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      return resolved.toString();
    } catch (err) {
      console.warn('resolveWsUrl failed, falling back to raw url', err);
      return rawUrl;
    }
  }
  function createWsConnection({url, panelId, errorNode, onMessage, onStatus}) {
    let socket = null;
    let closed = false;
    let reconnectTimer = null;
    let attempts = 0;
    function scheduleReconnect() {
      if (closed) return;
      const delay = Math.min(5000, 250 + attempts * 500);
      reconnectTimer = window.setTimeout(connect, delay);
    }
    function connect() {
      if (closed) return;
      attempts += 1;
      try {
        const resolvedUrl = resolveWsUrl(url);
        socket = new WebSocket(resolvedUrl);
      } catch (err) {
        if (errorNode) errorNode.textContent = `${panelId} ws error: ${err.message}`;
        scheduleReconnect();
        return;
      }
      socket.addEventListener('open', () => {
        attempts = 0;
        if (onStatus) onStatus('connected');
      });
      socket.addEventListener('close', () => {
        if (onStatus) onStatus('disconnected');
        if (!closed) scheduleReconnect();
      });
      socket.addEventListener('error', (event) => {
        if (errorNode && !errorNode.textContent) {
          errorNode.textContent = `${panelId} stream error`;
        }
        console.error('ws error', panelId, event);
      });
      socket.addEventListener('message', (event) => {
        try {
          onMessage(event.data);
        } catch (err) {
          if (errorNode && !errorNode.textContent) {
            errorNode.textContent = `${panelId} handler error: ${err && err.message ? err.message : err}`;
          }
        }
      });
    }
    connect();
    return {
      close() {
        closed = true;
        if (reconnectTimer) window.clearTimeout(reconnectTimer);
        if (socket && socket.readyState < 2) {
          socket.close();
        }
      }
    };
  }
  function unwrapStreamPayload(raw, arrayKeys = []) {
    if (raw === undefined || raw === null) return [];
    if (Array.isArray(raw)) return raw;
    if (typeof raw !== 'object') return [];
    if (Array.isArray(raw.data)) return raw.data;
    if (Array.isArray(raw.payload)) return raw.payload;
    if (Array.isArray(raw.items)) return raw.items;
    if (Array.isArray(raw.events)) return raw.events;
    if (Array.isArray(raw.rows)) return raw.rows;
    for (const key of arrayKeys) {
      if (Array.isArray(raw[key])) return raw[key];
    }
    if (raw.data !== undefined && raw.data !== null) return [raw.data];
    if (raw.payload !== undefined && raw.payload !== null) return [raw.payload];
    for (const key of arrayKeys) {
      if (raw[key] !== undefined && raw[key] !== null) return [raw[key]];
    }
    return [raw];
  }
  function persistSort(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (err) {
      console.warn('persist sort failed', err);
    }
  }
  function restoreSort(key) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (err) {
      return null;
    }
  }
  function attachSortableTable(table, rowsRef, renderFn, storageKey) {
    if (!table) return;
    const headers = table.querySelectorAll('th[data-sort]');
    let sortState = restoreSort(storageKey) || {key: headers[0] ? headers[0].dataset.sort : '', direction: 'desc'};
    function sortRows() {
      if (!sortState.key) return;
      const {key, direction} = sortState;
      const factor = direction === 'asc' ? 1 : -1;
      rowsRef.sort((a, b) => {
        const av = a[key];
        const bv = b[key];
        if (av === bv) return 0;
        if (av === undefined || av === null) return 1 * factor;
        if (bv === undefined || bv === null) return -1 * factor;
        if (typeof av === 'number' && typeof bv === 'number') {
          return (av - bv) * factor;
        }
        return String(av).localeCompare(String(bv)) * factor;
      });
    }
    sortRows();
    headers.forEach((th) => {
      th.addEventListener('click', () => {
        const key = th.dataset.sort;
        if (sortState.key === key) {
          sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
        } else {
          sortState = {key, direction: 'desc'};
        }
        persistSort(storageKey, sortState);
        sortRows();
        renderFn();
      });
    });
    return () => {
      sortRows();
      renderFn();
    };
  }
async function refreshHealth() {
  try {
    const [health, meta] = await Promise.all([
      safeFetchJson(ENDPOINTS.health, 'health', null, {headers: {Accept: 'application/json'}}).catch(() => null),
      safeFetchJson(ENDPOINTS.uiMeta, 'ui-meta', null, {headers: {Accept: 'application/json'}}).catch(() => null)
    ]);
    if (meta && typeof meta === 'object' && meta.rl_health_url) {
      state.rlHealthUrl = meta.rl_health_url;
    }
    let rlOk = null;
    if (state.rlHealthUrl) {
      try {
        const resp = await fetch(state.rlHealthUrl, {cache: 'no-store'});
        rlOk = resp.ok;
      } catch (err) {
        rlOk = null;
      }
    }
    const status = health && health.status ? health.status : 'unknown';
    if (status === 'ok' && rlOk !== false) {
      setHealthPill('green', 'Nominal');
    } else if (status === 'ok' && rlOk === false) {
      setHealthPill('warning', 'RL degraded');
    } else if (status === 'degraded') {
      setHealthPill('warning', 'Degraded');
    } else if (status === 'critical') {
      setHealthPill('red', 'Critical');
    } else {
      setHealthPill('warning', 'Unknown');
    }
  } catch (err) {
    setHealthPill('warning', 'Unknown');
  }
}
    function updateRunHeader(runState) {
      const mode = doc.getElementById('pill-mode');
      const workflow = doc.getElementById('pill-workflow');
      const keypair = doc.getElementById('keypair-display');
      const budget = doc.getElementById('budget-remaining');
      const risk = doc.getElementById('risk-current');
      const throttle = doc.getElementById('throttle-backoff');
      const rps = doc.getElementById('rps-limits');
      if (!runState) {
        mode.textContent = 'Mode: —';
        workflow.textContent = 'Workflow: —';
        keypair.textContent = '—';
        budget.textContent = '—';
        risk.textContent = '—';
        throttle.textContent = '—';
        rps.textContent = '—';
        return;
      }
      state.runState = {...(state.runState || {}), ...runState};
      const merged = state.runState;
      mode.textContent = `Mode: ${merged.mode || '—'}`;
      workflow.textContent = `Workflow: ${merged.workflow || '—'}`;
      const fingerprint = merged.keypair_pubkey || merged.keypair_fingerprint || '—';
      const keypairPath = state.keypairPath || merged.keypair_path || '';
      if (fingerprint && keypairPath) {
        keypair.textContent = `${fingerprint} · ${keypairPath}`;
      } else if (fingerprint !== '—') {
        keypair.textContent = fingerprint;
      } else if (keypairPath) {
        keypair.textContent = keypairPath;
      } else {
        keypair.textContent = '—';
      }
      budget.textContent = merged.budget_remaining !== undefined ? formatCurrency(merged.budget_remaining) : '—';
      risk.textContent = merged.risk_current !== undefined ? formatNumber(merged.risk_current, 4) : '—';
      const throttleParts = [];
      if (merged.rpc_backoff) throttleParts.push(`Backoff ${merged.rpc_backoff}`);
      if (merged.throttle_state) throttleParts.push(merged.throttle_state);
      throttle.textContent = throttleParts.length ? throttleParts.join(' · ') : 'Nominal';
      const limits = merged.rps_limits;
      rps.textContent = Array.isArray(limits) ? limits.join(', ') : (limits || '—');
      setLivePill(Boolean(merged.canary));
      doc.dispatchEvent(new CustomEvent('run-state-update', {detail: merged}));
      hydration.runHeader = true;
    }
async function loadRunStateSnapshot() {
  const runState = await safeFetchJson(ENDPOINTS.runStateSnapshot, 'run-state', null, {headers: {Accept: 'application/json'}}).catch(() => null);
  if (runState) {
    state.runState = runState;
    updateRunHeader(runState);
  }
}
async function loadEnvForHeader() {
  try {
    const env = await safeFetchJson(ENDPOINTS.runEnv, 'run-env-header', null, {headers: {Accept: 'application/json'}}).catch(() => null);
    if (env && typeof env === 'object') {
      if (env.KEYPAIR_PATH) {
        state.keypairPath = env.KEYPAIR_PATH;
        if (state.runState) {
          updateRunHeader(state.runState);
        }
      }
    }
  } catch (err) {
    /* env fetch optional */
  }
}
function connectRunStateStream() {
  const statusLabel = doc.getElementById('run-stream-status');
  if (statusLabel) {
    statusLabel.textContent = 'Run state: connecting…';
  }
  return createWsConnection({
    url: ENDPOINTS.runStateStream,
    panelId: 'run-state',
    errorNode: null,
    onStatus: (status) => {
      if (!statusLabel) return;
      if (status === 'connected') {
        statusLabel.textContent = 'Run state: live';
      } else {
        statusLabel.textContent = 'Run state: reconnecting…';
      }
    },
    onMessage: (payload) => {
      const parsed = safeJsonParse(payload, 'run-state', null);
      const frames = unwrapStreamPayload(parsed, ['state']);
      frames.forEach((entry) => {
        if (!entry || typeof entry !== 'object') return;
        updateRunHeader(entry);
      });
    }
  });
}
function setupRunHeader() {
  loadRunStateSnapshot();
  loadEnvForHeader();
  refreshHealth();
  connectRunStateStream();
  window.setInterval(refreshHealth, 15000);
  window.setInterval(() => {
    loadRunStateSnapshot();
  }, 10000);
  const copyEnvBtn = doc.getElementById('copy-env-btn');
  if (copyEnvBtn) {
    copyEnvBtn.addEventListener('click', async () => {
      copyEnvBtn.disabled = true;
      try {
        const env = await safeFetchJson(ENDPOINTS.runEnv, 'run-env', null, {headers: {Accept: 'application/json'}});
        if (env && env.KEYPAIR_PATH && env.KEYPAIR_PATH !== state.keypairPath) {
          state.keypairPath = env.KEYPAIR_PATH;
          if (state.runState) {
            updateRunHeader(state.runState);
          }
        }
        copyToClipboard(JSON.stringify(env || {}, null, 2));
      } finally {
        copyEnvBtn.disabled = false;
      }
    });
  }
}
function normalizeDiscoveryEvent(raw, tokenMetaCache) {
  if (!raw) return null;
  const mint = raw.mint || raw.token || raw.id;
  if (!mint) return null;
  const ts = toMillis(raw.ts || raw.timestamp || raw.time);
  const meta = tokenMetaCache.get(mint) || {};
  return {
    mint,
    ts,
    local: formatTimestamp(ts),
    source: raw.source || raw.kind || 'unknown',
    symbol: raw.symbol || meta.symbol || raw.ticker || '—',
    name: raw.name || meta.name || '—',
    routes: Array.isArray(raw.routes) ? raw.routes.join(', ') : (raw.route || '—'),
    quality: Number(raw.quality_score || raw.score || 0)
  };
}
function setupDiscoveryPanel() {
  const panel = doc.getElementById('panel-discovery');
  if (!panel) return;
  const statusNode = panel.querySelector('[data-role="status"]');
  const timeline = panel.querySelector('[data-role="timeline"]');
  const errorNode = panel.querySelector('[data-role="error"]');
  const windowSelect = panel.querySelector('select[data-control="window"]');
  const pauseBtn = panel.querySelector('button[data-control="pause"]');
  const tokenMetaCache = new Map();
  let wsRef = null;
  function render() {
    const now = Date.now();
    const windowMs = state.discoveryWindow * 1000;
    const filtered = state.discoveryEvents.filter((event) => now - event.ts <= windowMs);
    timeline.innerHTML = '';
    if (!filtered.length) {
      statusNode.textContent = state.discoveryPaused ? 'Paused — timeline frozen' : 'No discovery events yet';
      return;
    }
    statusNode.textContent = `${filtered.length} opportunities`;
    filtered.forEach((event) => {
      const item = doc.createElement('div');
      item.className = 'timeline-item';
      if (state.selectedMint && event.mint === state.selectedMint) {
        item.classList.add('selected');
      }
      item.dataset.mint = event.mint;
      item.innerHTML = `
        <div class="meta"><span title="${event.local.utc}">${event.local.label}</span><span>${event.source}</span></div>
        <div><strong>${event.symbol}</strong> · ${event.name}</div>
        <div class="panel-status">Route: ${event.routes} · Score ${formatNumber(event.quality, 2)}</div>
      `;
      item.addEventListener('click', () => selectedMintStore.set(event.mint));
      timeline.appendChild(item);
    });
  }
  async function hydrateMeta(mint) {
    if (!mint || tokenMetaCache.has(mint)) return;
    try {
      const meta = await safeFetchJson(ENDPOINTS.tokenMetaResolver(mint), 'discovery-meta', errorNode, {headers: {Accept: 'application/json'}});
      if (meta && typeof meta === 'object') {
        tokenMetaCache.set(mint, {symbol: meta.symbol || meta.ticker || '—', name: meta.name || '—'});
      }
    } catch (err) {
      /* ignore meta errors */
    }
  }
  function ingest(rows) {
    const items = Array.isArray(rows) ? rows : [rows];
    items.forEach((row) => {
      const normalized = normalizeDiscoveryEvent(row, tokenMetaCache);
      if (!normalized) return;
      hydrateMeta(normalized.mint);
      state.discoveryEvents.unshift(normalized);
    });
    state.discoveryEvents = state.discoveryEvents.slice(0, 600);
    hydration.discovery = true;
    render();
  }
  async function loadSnapshot() {
    statusNode.textContent = 'Loading snapshot…';
    try {
      const snapshot = await safeFetchJson(ENDPOINTS.discoverySnapshot, 'discovery', errorNode, {headers: {Accept: 'application/json'}});
      if (Array.isArray(snapshot)) {
        state.discoveryEvents = snapshot.map((row) => normalizeDiscoveryEvent(row, tokenMetaCache)).filter(Boolean);
        state.discoveryEvents.sort((a, b) => b.ts - a.ts);
        hydration.discovery = true;
        render();
      }
    } catch (err) {
      statusNode.textContent = 'Failed to load discovery snapshot';
    }
  }
  function startStream() {
    if (wsRef) wsRef.close();
    wsRef = createWsConnection({
      url: ENDPOINTS.discoveryStream,
      panelId: 'discovery',
      errorNode,
      onStatus: (status) => {
        if (status === 'connected') {
          statusNode.textContent = 'Live feed';
        } else if (!state.discoveryPaused) {
          statusNode.textContent = 'Backoff — optimistic UI';
        }
      },
      onMessage: (payload) => {
        if (state.discoveryPaused) return;
        const parsed = safeJsonParse(payload, 'discovery', errorNode);
        const frames = unwrapStreamPayload(parsed, ['events', 'discoveries', 'opportunities']);
        frames.forEach((frame) => ingest(frame));
      }
    });
  }
  windowSelect.addEventListener('change', () => {
    state.discoveryWindow = Number(windowSelect.value);
    render();
  });
  pauseBtn.addEventListener('click', () => {
    state.discoveryPaused = !state.discoveryPaused;
    pauseBtn.textContent = state.discoveryPaused ? 'Resume' : 'Pause';
    if (state.discoveryPaused) {
      if (wsRef) wsRef.close();
      statusNode.textContent = 'Paused — stream halted';
    } else {
      startStream();
      render();
    }
  });
  loadSnapshot().then(() => {
    render();
    startStream();
  });
}
function drawSparkline(canvas, values) {
  if (!canvas || !canvas.getContext) return;
  const ctx = canvas.getContext('2d');
  const width = canvas.clientWidth || 200;
  const height = canvas.clientHeight || 60;
  canvas.width = width;
  canvas.height = height;
  ctx.clearRect(0, 0, width, height);
  if (!values || values.length < 2) {
    ctx.strokeStyle = 'rgba(75,130,255,0.6)';
    ctx.beginPath();
    ctx.moveTo(0, height / 2);
    ctx.lineTo(width, height / 2);
    ctx.stroke();
    return;
  }
  const min = Math.min(...values);
  const max = Math.max(...values);
  const span = max - min || 1;
  ctx.strokeStyle = 'rgba(75,130,255,0.85)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  values.forEach((val, index) => {
    const x = (index / (values.length - 1)) * width;
    const y = height - ((val - min) / span) * height;
    if (index === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  });
  ctx.stroke();
}
function setupTokenPanel() {
  const panel = doc.getElementById('panel-token');
  if (!panel) return;
  const statusNode = panel.querySelector('[data-role="status"]');
  const metaGrid = panel.querySelector('[data-role="meta"]');
  const badges = panel.querySelector('[data-role="badges"]');
  const errorNode = panel.querySelector('[data-role="error"]');
  const sparklineCanvas = panel.querySelector('canvas[data-role="sparkline"]');
  const invalidBanner = panel.querySelector('[data-role="invalid"]');
  const pauseBtn = panel.querySelector('button[data-control="pause"]');
  let pricePoints = [];
  let priceWs = null;
  let depthWs = null;
  let currentMint = null;
  function closeStreams() {
    if (priceWs) priceWs.close();
    if (depthWs) depthWs.close();
    priceWs = null;
    depthWs = null;
  }
  function renderMeta(meta, price) {
    metaGrid.innerHTML = '';
    badges.innerHTML = '';
    if (!meta) {
      statusNode.textContent = 'Pick a discovery candidate.';
      drawSparkline(sparklineCanvas, []);
      return;
    }
    const entries = [
      ['Symbol', meta.symbol || '—'],
      ['Name', meta.name || '—'],
      ['Mint', currentMint || '—'],
      ['Liquidity', price && price.liquidity !== undefined ? formatCurrency(price.liquidity) : '—'],
      ['Holders', meta.holders !== undefined ? formatNumber(meta.holders, 0) : '—'],
      ['Pool', Array.isArray(meta.pools) ? meta.pools.join(', ') : (meta.pool || '—')],
      ['Price', price && price.price !== undefined ? formatNumber(price.price, 6) : '—'],
      ['24h Return', price && price.returns !== undefined ? formatPercent(price.returns) : '—']
    ];
    entries.forEach(([label, value]) => {
      const dl = doc.createElement('dl');
      dl.innerHTML = `<dt>${label}</dt><dd>${value}</dd>`;
      metaGrid.appendChild(dl);
    });
    const provenance = [];
    if (meta.pyth || meta.price_source === 'pyth') provenance.push('pyth');
    if (meta.dexscreener) provenance.push('dexscreener');
    if (meta.birdeye) provenance.push('birdeye');
    if (meta.synthetic) provenance.push('synthetic');
    if (Array.isArray(meta.provenance)) {
      meta.provenance.forEach((p) => provenance.push(String(p)));
    }
    [...new Set(provenance)].forEach((label) => {
      const badge = doc.createElement('span');
      badge.className = 'badge';
      badge.textContent = label;
      badges.appendChild(badge);
    });
    if (currentMint) {
      updatePriceSnapshot(currentMint, {
        price: price ? price.price ?? price.px : undefined,
        mark: price ? price.mark ?? price.mark_price : undefined,
        mid: price ? price.mid ?? price.mid_price : undefined,
        reference_price: price ? price.reference_price ?? price.reference ?? price.target_price : undefined
      });
    }
    hydration.token = true;
  }
  async function hydrateToken(mint) {
    if (!mint) {
      renderMeta(null, null);
      return;
    }
    statusNode.textContent = 'Loading token…';
    try {
      const [meta, price] = await Promise.all([
        safeFetchJson(ENDPOINTS.tokenMeta(mint), 'token-meta', errorNode, {headers: {Accept: 'application/json'}}).catch(() => null),
        safeFetchJson(ENDPOINTS.tokenPrice(mint), 'token-price', errorNode, {headers: {Accept: 'application/json'}}).catch(() => null)
      ]);
      renderMeta(meta || {}, price || {});
      pricePoints = [];
      if (price && Array.isArray(price.history)) {
        pricePoints = price.history.map((row) => Number(row.price || row.px)).filter((val) => Number.isFinite(val));
        drawSparkline(sparklineCanvas, pricePoints.slice(-120));
      }
      invalidBanner.hidden = true;
      if (currentMint) {
        updatePriceSnapshot(currentMint, price || {});
      }
      statusNode.textContent = 'Live';
      hydration.token = true;
    } catch (err) {
      statusNode.textContent = 'Failed to load token';
    }
  }
  function attachPriceStream(mint) {
    if (!mint || state.tokenPaused) return;
    priceWs = createWsConnection({
      url: ENDPOINTS.tokenPriceStream(mint),
      panelId: 'token-price',
      errorNode,
      onStatus: (status) => {
        if (status === 'connected') {
          statusNode.textContent = 'Live';
        } else if (!state.tokenPaused) {
          statusNode.textContent = 'Backoff — optimistic UI';
        }
      },
      onMessage: (payload) => {
        const parsed = safeJsonParse(payload, 'token-price', errorNode);
        const frames = unwrapStreamPayload(parsed, ['ticks', 'prices', 'candles', 'data']);
        frames.forEach((data) => {
          if (!data || (data.mint && data.mint !== mint)) return;
          updatePriceSnapshot(mint, data);
          if (data.meta) {
            renderMeta(data.meta, data);
          }
          if (typeof data.price === 'number' || typeof data.c === 'number') {
            const point = maybeNumber(data.price ?? data.close ?? data.c);
            if (point !== null) {
              pricePoints.push(point);
              pricePoints = pricePoints.slice(-240);
              drawSparkline(sparklineCanvas, pricePoints);
            }
          }
        });
      }
    });
  }
  function attachDepthStream(mint) {
    if (!mint || state.tokenPaused) return;
    depthWs = createWsConnection({
      url: ENDPOINTS.tokenDepthStream(mint),
      panelId: 'token-depth',
      errorNode,
      onMessage: (payload) => {
        const parsed = safeJsonParse(payload, 'token-depth', errorNode);
        const frames = unwrapStreamPayload(parsed, ['depth', 'book', 'levels', 'data']);
        frames.forEach((data) => {
          if (!data || (data.mint && data.mint !== mint)) return;
          if (data.status === 'invalid_mint') {
            invalidBanner.hidden = false;
            return;
          }
          invalidBanner.hidden = true;
          const book = normalizeOrderbookPayload(data);
          if (book && currentMint) {
            state.depthByMint.set(currentMint, book);
            if (book.bids.length && book.asks.length) {
              const mid = (book.bids[0][0] + book.asks[0][0]) / 2;
              updatePriceSnapshot(currentMint, {mid});
            }
            doc.dispatchEvent(new CustomEvent('orderbook-update', {detail: {mint: currentMint, book}}));
          }
        });
      }
    });
  }
  pauseBtn.addEventListener('click', () => {
    state.tokenPaused = !state.tokenPaused;
    pauseBtn.textContent = state.tokenPaused ? 'Resume' : 'Pause';
    if (state.tokenPaused) {
      closeStreams();
      statusNode.textContent = 'Paused';
    } else if (currentMint) {
      hydrateToken(currentMint).then(() => {
        attachPriceStream(currentMint);
        attachDepthStream(currentMint);
      });
    }
  });
  selectedMintStore.subscribe((mint) => {
    state.selectedMint = mint;
    if (state.discoveryEvents.length) {
      // highlight timeline selection
      state.discoveryEvents.forEach((event) => {
        if (event.mint === mint) {
          hydration.discovery = true;
        }
      });
    }
    closeStreams();
    currentMint = mint;
    if (!mint) {
      renderMeta(null, null);
      statusNode.textContent = 'Pick a discovery candidate.';
      return;
    }
    if (state.tokenPaused) {
      statusNode.textContent = 'Paused';
      return;
    }
    hydrateToken(mint).then(() => {
      attachPriceStream(mint);
      attachDepthStream(mint);
    });
  });
}
function setupAgentPanel() {
  const panel = doc.getElementById('panel-agents');
  if (!panel) return;
  const statusNode = panel.querySelector('[data-role="status"]');
  const timeline = panel.querySelector('[data-role="timeline"]');
  const errorNode = panel.querySelector('[data-role="error"]');
  const windowSelect = panel.querySelector('select[data-control="window"]');
  const pauseBtn = panel.querySelector('button[data-control="pause"]');
  let wsRef = null;
  let currentMint = null;
  let events = [];
  function render() {
    timeline.innerHTML = '';
    if (!events.length) {
      statusNode.textContent = currentMint ? 'No agent events yet' : 'Waiting for mint…';
      return;
    }
    statusNode.textContent = `${events.length} agent events`;
    events.forEach((event) => {
      const item = doc.createElement('div');
      item.className = 'timeline-item';
      item.innerHTML = `
        <div class="meta"><span title="${event.utc}">${event.label}</span><span>${event.agent}</span></div>
        <div><strong>${event.intent}</strong> @ ${formatNumber(event.confidence * 100, 2)}%</div>
        <div class="panel-status">${event.features}</div>
        ${event.error ? `<div class="inline-error">${event.error}</div>` : ''}
      `;
      timeline.appendChild(item);
    });
    hydration.agents = true;
  }
  function setEvents(list) {
    const now = Date.now();
    const windowMs = state.agentWindow * 1000;
    events = list.filter((event) => now - event.ts <= windowMs);
    render();
  }
  async function loadBackfill(mint) {
    if (!mint) {
      events = [];
      render();
      return;
    }
    statusNode.textContent = 'Backfilling…';
    try {
      const since = Date.now() - state.agentWindow * 1000;
      const data = await safeFetchJson(ENDPOINTS.agentEventsBackfill(mint, since), 'agents-backfill', errorNode, {headers: {Accept: 'application/json'}});
      if (Array.isArray(data)) {
        const mapped = data.map((row) => {
          const ts = toMillis(row.ts || row.timestamp);
          const formatted = formatTimestamp(ts);
          return {
            ts,
            label: formatted.label,
            utc: formatted.utc,
            agent: row.agent_id || row.agent || 'unknown',
            intent: row.intent || 'hold',
            confidence: Number(row.confidence || 0),
            features: JSON.stringify(row.features || {}),
            error: row.error || null
          };
        });
        events = mapped;
        hydration.agents = true;
        setEvents(events);
      }
    } catch (err) {
      statusNode.textContent = 'Agent backfill failed';
    }
  }
  function startStream(mint) {
    if (wsRef) wsRef.close();
    if (!mint || state.agentPaused) return;
    wsRef = createWsConnection({
      url: ENDPOINTS.agentEventsStream(mint),
      panelId: 'agents',
      errorNode,
      onStatus: (status) => {
        if (status === 'connected') {
          statusNode.textContent = 'Live agent feed';
        } else if (!state.agentPaused) {
          statusNode.textContent = 'Backoff — optimistic UI';
        }
      },
      onMessage: (payload) => {
        if (state.agentPaused) return;
        const parsed = safeJsonParse(payload, 'agents', errorNode);
        const frames = unwrapStreamPayload(parsed, ['events', 'messages', 'suggestions']);
        frames.forEach((row) => {
          if (!row || (row.mint && row.mint !== currentMint)) return;
          const ts = toMillis(row.ts || row.timestamp);
          const formatted = formatTimestamp(ts);
          events.push({
            ts,
            label: formatted.label,
            utc: formatted.utc,
            agent: row.agent_id || row.agent || row.source || 'unknown',
            intent: row.intent || row.action || 'hold',
            confidence: Number(row.confidence || row.score || 0),
            features: JSON.stringify(row.features || row.metrics || {}),
            error: row.error || null
          });
        });
        events.sort((a, b) => a.ts - b.ts);
        hydration.agents = true;
        setEvents(events);
      }
    });
  }
  pauseBtn.addEventListener('click', () => {
    state.agentPaused = !state.agentPaused;
    pauseBtn.textContent = state.agentPaused ? 'Resume' : 'Pause';
    if (state.agentPaused) {
      if (wsRef) wsRef.close();
      statusNode.textContent = 'Paused';
    } else {
      loadBackfill(currentMint).then(() => startStream(currentMint));
    }
  });
  windowSelect.addEventListener('change', () => {
    state.agentWindow = Number(windowSelect.value);
    setEvents(events);
  });
  selectedMintStore.subscribe((mint) => {
    currentMint = mint;
    if (state.agentPaused) {
      statusNode.textContent = 'Paused';
      return;
    }
    loadBackfill(mint).then(() => startStream(mint));
  });
}
function setupPlannerPanel() {
  const panel = doc.getElementById('panel-planner');
  if (!panel) return;
  const statusNode = panel.querySelector('[data-role="status"]');
  const planGrid = panel.querySelector('[data-role="plan"]');
  const dryRunNode = panel.querySelector('[data-role="dry-run"]');
  const errorNode = panel.querySelector('[data-role="error"]');
  const pauseBtn = panel.querySelector('button[data-control="pause"]');
  let wsRef = null;
  let currentMint = null;
  function renderPlan(plan) {
    planGrid.innerHTML = '';
    dryRunNode.innerHTML = 'Dry-run pending…';
    if (!plan) {
      statusNode.textContent = currentMint ? 'No plan available' : 'Waiting for mint…';
      return;
    }
    if (currentMint) {
      updatePriceSnapshot(currentMint, {
        __source: 'plan',
        price: plan.price,
        mark: plan.mark ?? plan.mark_price,
        mid: plan.mid_price,
        reference_price: plan.reference_price ?? plan.mark_price ?? plan.mark
      });
    }
    const entries = [
      ['Intent', plan.intent || plan.action || '—'],
      ['Router', plan.router || plan.route || '—'],
      ['Size', (() => {
        const size = extractPlanSize(plan);
        return size !== null ? formatNumber(size, 4) : (plan.size !== undefined ? formatNumber(plan.size, 4) : '—');
      })()],
      ['Slippage', plan.slippage_bps !== undefined ? `${formatNumber(plan.slippage_bps, 2)} bps` : '—'],
      ['Bundle', plan.bundle_preference || plan.bundle || '—'],
      ['Budget Ref', plan.budget_reference || '—'],
      ['Risk Slot', plan.risk_slot || '—'],
      ['Quote', plan.quote_currency || '—']
    ];
    entries.forEach(([label, value]) => {
      const dl = doc.createElement('dl');
      dl.innerHTML = `<dt>${label}</dt><dd>${value}</dd>`;
      planGrid.appendChild(dl);
    });
    const segments = [];
    const simulation = currentMint ? simulatePlanFill(currentMint, plan) : null;
    if (simulation) {
      const impactLabel = simulation.impactPct !== null ? `${formatNumber(simulation.impactPct, 2)}%` : 'n/a';
      const tsLabel = formatTimestamp(simulation.ts || Date.now());
      let summary = `Simulated ${simulation.side} ${formatNumber(simulation.filled, 4)} @ ${formatNumber(simulation.avgPrice, 6)} (${impactLabel})`;
      if (simulation.remaining > 0) {
        summary += ` · Unfilled ${formatNumber(simulation.remaining, 4)}`;
      }
      summary += ` · Depth ${tsLabel.label}`;
      segments.push(summary);
    }
    if (plan.dry_run) {
      segments.push(`Plan dry-run: ${formatPercent(plan.dry_run.price_impact || 0)} · Fill ${formatNumber(plan.dry_run.expected_fill || 0, 4)}`);
    }
    dryRunNode.innerHTML = segments.length ? segments.map((text) => `<div>${text}</div>`).join('') : 'Dry-run pending…';
    hydration.planner = true;
  }
  async function loadSnapshot(mint) {
    if (!mint) {
      renderPlan(null);
      return;
    }
    statusNode.textContent = 'Loading plan…';
    try {
      const plan = await safeFetchJson(ENDPOINTS.executionPlanSnapshot(mint), 'execution-plan', errorNode, {headers: {Accept: 'application/json'}});
      if (plan && typeof plan === 'object') {
        state.planByMint.set(mint, plan);
        renderPlan(plan);
        statusNode.textContent = 'Live';
      } else {
        state.planByMint.delete(mint);
        renderPlan(null);
      }
      hydration.planner = true;
    } catch (err) {
      statusNode.textContent = 'Plan snapshot failed';
    }
  }
  function startStream(targetMint = currentMint) {
    if (wsRef) wsRef.close();
    if (!targetMint || state.plannerPaused) return;
    wsRef = createWsConnection({
      url: ENDPOINTS.executionPlanStream(targetMint),
      panelId: 'execution-plan',
      errorNode,
      onStatus: (status) => {
        if (status === 'connected') {
          statusNode.textContent = 'Live';
        } else if (!state.plannerPaused) {
          statusNode.textContent = 'Backoff — optimistic UI';
        }
      },
      onMessage: (payload) => {
        if (state.plannerPaused) return;
        const parsed = safeJsonParse(payload, 'execution-plan', errorNode);
        const items = unwrapStreamPayload(parsed, ['plan', 'data']);
        items.forEach((plan) => {
          if (!plan || (plan.mint && plan.mint !== targetMint)) {
            if (plan && plan.mint) {
              state.planByMint.set(plan.mint, plan);
            }
            return;
          }
          state.planByMint.set(targetMint, plan);
          if (targetMint === currentMint) {
            renderPlan(plan);
          }
          hydration.planner = true;
        });
      }
    });
  }
  pauseBtn.addEventListener('click', () => {
    state.plannerPaused = !state.plannerPaused;
    pauseBtn.textContent = state.plannerPaused ? 'Resume' : 'Pause';
    if (state.plannerPaused) {
      if (wsRef) wsRef.close();
      statusNode.textContent = 'Paused';
    } else {
      loadSnapshot(currentMint).then(() => startStream(currentMint));
    }
  });
  selectedMintStore.subscribe((mint) => {
    currentMint = mint;
    if (state.plannerPaused) {
      statusNode.textContent = 'Paused';
      return;
    }
    if (mint && state.planByMint.has(mint)) {
      renderPlan(state.planByMint.get(mint));
      statusNode.textContent = 'Live';
    } else {
      renderPlan(null);
    }
    loadSnapshot(mint).then(() => startStream(mint));
  });
  const refreshPlanView = (event) => {
    if (!event || !event.detail || event.detail.mint !== currentMint) return;
    if (event.detail.origin === 'plan') return;
    const plan = currentMint ? state.planByMint.get(currentMint) : null;
    if (plan) {
      renderPlan(plan);
    }
  };
  doc.addEventListener('orderbook-update', refreshPlanView);
  doc.addEventListener('price-snapshot-update', refreshPlanView);
  startStream(currentMint);
}
function setupOrdersPanel() {
  const panel = doc.getElementById('panel-orders');
  if (!panel) return;
  const statusNode = panel.querySelector('[data-role="status"]');
  const rowsBody = panel.querySelector('[data-role="rows"]');
  const summaryNode = panel.querySelector('[data-role="summary"]');
  const errorNode = panel.querySelector('[data-role="error"]');
  const windowSelect = panel.querySelector('select[data-control="window"]');
  const pauseBtn = panel.querySelector('button[data-control="pause"]');
  const table = panel.querySelector('table');
  const ordersRows = [];
  function render() {
    rowsBody.innerHTML = '';
    if (!ordersRows.length) {
      const row = doc.createElement('tr');
      row.className = 'empty';
      row.innerHTML = '<td colspan="9">No orders yet</td>';
      rowsBody.appendChild(row);
      summaryNode.textContent = '—';
      statusNode.textContent = state.ordersPaused ? 'Paused — timeline frozen' : 'No orders yet';
      return;
    }
    hydration.orders = true;
    ordersRows.forEach((order) => {
      const row = doc.createElement('tr');
      const timeCell = formatTimestamp(order.ts);
      const txHref = order.txid ? `https://solscan.io/tx/${order.txid}` : '#';
      row.innerHTML = `
        <td title="${timeCell.utc}">${timeCell.label}</td>
        <td>${order.mint}</td>
        <td>${order.side}</td>
        <td>${formatNumber(order.qty, 4)}</td>
        <td>${order.route}</td>
        <td>${order.quote_price} → ${order.fill_price}</td>
        <td class="${order.slippage_bps > 0 ? 'numeric-down' : 'numeric-up'}">${formatNumber(order.slippage_bps, 2)}</td>
        <td>${formatCurrency(order.fees)}</td>
        <td>${order.status}${order.txid ? ` · <a class="link-out" data-txid="${order.txid}" href="${txHref}" target="_blank" rel="noreferrer">tx</a>` : ''}</td>
      `;
      const link = row.querySelector('a[data-txid]');
      if (link) {
        link.addEventListener('click', (event) => {
          event.stopPropagation();
        });
        link.addEventListener('dblclick', (event) => {
          event.preventDefault();
          copyToClipboard(link.dataset.txid);
        });
      }
      rowsBody.appendChild(row);
    });
    const aggregation = new Map();
    ordersRows.forEach((order) => {
      const bucket = aggregation.get(order.mint) || {slippage: 0, count: 0, fees: 0};
      bucket.slippage += order.slippage_bps;
      bucket.count += 1;
      bucket.fees += order.fees;
      aggregation.set(order.mint, bucket);
    });
    const summaryParts = [];
    aggregation.forEach((bucket, mint) => {
      summaryParts.push(`${mint}: avg ${formatNumber(bucket.slippage / bucket.count, 2)} bps · fees ${formatCurrency(bucket.fees)}`);
    });
    summaryNode.textContent = summaryParts.join(' | ') || '—';
  }
  const sortAndRender = attachSortableTable(table, ordersRows, render, 'orders-sort');
  function updateOrders() {
    const windowSec = Number(state.ordersWindow);
    const windowMs = windowSec > 0 ? windowSec * 1000 : null;
    const cutoff = windowMs ? Date.now() - windowMs : null;
    const filtered = cutoff ? state.orders.filter((order) => order.ts >= cutoff) : state.orders.slice();
    ordersRows.splice(0, ordersRows.length, ...filtered.map((order) => ({...order})));
    if (sortAndRender) sortAndRender(); else render();
  }
  async function loadSnapshot() {
    statusNode.textContent = 'Loading orders…';
    try {
      const data = await safeFetchJson(ENDPOINTS.fillsSnapshot, 'orders', errorNode, {headers: {Accept: 'application/json'}});
      if (Array.isArray(data)) {
        state.orders = data.map((row) => ({
          ts: toMillis(row.ts || row.timestamp),
          mint: row.mint || row.token || '—',
          side: row.side || '—',
          qty: Number(row.qty || row.quantity || 0),
          route: row.route || (Array.isArray(row.routes) ? row.routes.join(', ') : '—'),
          quote_price: row.quote_price !== undefined ? formatNumber(row.quote_price, 6) : '—',
          fill_price: row.fill_price !== undefined ? formatNumber(row.fill_price, 6) : '—',
          slippage_bps: Number(row.slippage_bps || row.slippage || 0),
          fees: Number(row.fees || 0),
          status: row.status || 'pending',
          txid: row.txid || row.signature || null
        }));
        hydration.orders = true;
        updateOrders();
        statusNode.textContent = 'Live';
      }
    } catch (err) {
      statusNode.textContent = 'Order snapshot failed';
    }
  }
  let wsRef = null;
  function startStream() {
    if (wsRef) wsRef.close();
    wsRef = createWsConnection({
      url: ENDPOINTS.fillsStream,
      panelId: 'orders',
      errorNode,
      onStatus: (status) => {
        if (status === 'connected') {
          statusNode.textContent = 'Live';
        } else if (!state.ordersPaused) {
          statusNode.textContent = 'Backoff — optimistic UI';
        }
      },
      onMessage: (payload) => {
        if (state.ordersPaused) return;
        const parsed = safeJsonParse(payload, 'orders', errorNode);
        const rows = unwrapStreamPayload(parsed, ['fills', 'orders', 'executions']);
        rows.forEach((row) => {
          const order = {
            ts: toMillis(row.ts || row.timestamp),
            mint: row.mint || row.token || '—',
            side: row.side || row.direction || row.intent || '—',
            qty: Number(row.qty || row.quantity || row.base_amount || 0),
            route: row.route || row.router || (Array.isArray(row.routes) ? row.routes.join(', ') : '—'),
            quote_price: row.quote_price !== undefined ? formatNumber(row.quote_price, 6) : '—',
            fill_price: row.fill_price !== undefined ? formatNumber(row.fill_price, 6) : (row.price_usd !== undefined ? formatNumber(row.price_usd, 6) : '—'),
            slippage_bps: Number(row.slippage_bps || row.slippage || 0),
            fees: Number(row.fees || row.fee || 0),
            status: row.status || row.fill_status || 'pending',
            txid: row.txid || row.signature || row.tx || null
          };
          state.orders.unshift(order);
        });
        state.orders = state.orders.slice(0, 800);
        hydration.orders = true;
        updateOrders();
      }
    });
  }
  windowSelect.addEventListener('change', () => {
    state.ordersWindow = Number(windowSelect.value);
    updateOrders();
  });
  pauseBtn.addEventListener('click', () => {
    state.ordersPaused = !state.ordersPaused;
    pauseBtn.textContent = state.ordersPaused ? 'Resume' : 'Pause';
    if (state.ordersPaused) {
      if (wsRef) wsRef.close();
      statusNode.textContent = 'Paused';
    } else {
      updateOrders();
      startStream();
    }
  });
  loadSnapshot().then(() => {
    updateOrders();
    startStream();
  });
}
function setupPositionsPanel() {
  const panel = doc.getElementById('panel-positions');
  if (!panel) return;
  const statusNode = panel.querySelector('[data-role="status"]');
  const rowsBody = panel.querySelector('[data-role="rows"]');
  const budgetNode = panel.querySelector('[data-role="budget"]');
  const errorNode = panel.querySelector('[data-role="error"]');
  const pauseBtn = panel.querySelector('button[data-control="pause"]');
  const table = panel.querySelector('table');
  const positionsRows = [];
  function renderBudget() {
    const runState = state.runState;
    if (!runState) {
      budgetNode.textContent = 'Budget widget pending…';
      return;
    }
    budgetNode.textContent = `Budget ${formatCurrency(runState.budget_remaining)} · Reserved ${formatCurrency(runState.budget_reserved || 0)}`;
  }
  function render() {
    rowsBody.innerHTML = '';
    if (!positionsRows.length) {
      const row = doc.createElement('tr');
      row.className = 'empty';
      row.innerHTML = '<td colspan="8">No open positions</td>';
      rowsBody.appendChild(row);
      return;
    }
    hydration.positions = true;
    positionsRows.forEach((position) => {
      const row = doc.createElement('tr');
      row.innerHTML = `
        <td>${position.mint}</td>
        <td>${formatNumber(position.qty, 4)}</td>
        <td>${formatNumber(position.avg_cost, 6)}</td>
        <td>${formatNumber(position.mark, 6)}</td>
        <td class="${position.ue_pnl >= 0 ? 'numeric-up' : 'numeric-down'}">${formatCurrency(position.ue_pnl)}</td>
        <td class="${position.realized_pnl >= 0 ? 'numeric-up' : 'numeric-down'}">${formatCurrency(position.realized_pnl)}</td>
        <td>${formatNumber(position.risk, 4)}</td>
        <td class="portfolio-actions"></td>
      `;
      const actionsCell = row.querySelector('.portfolio-actions');
      const closeBtn = doc.createElement('button');
      closeBtn.textContent = 'Close';
      const trimBtn = doc.createElement('button');
      trimBtn.textContent = 'Trim 50%';
      const plan = state.planByMint.get(position.mint);
      const canary = state.runState && state.runState.canary;
      const planHold = plan && (plan.intent === 'hold' || plan.intent === 'skip' || plan.action === 'hold');
      const disableActions = canary || planHold;
      closeBtn.disabled = disableActions;
      trimBtn.disabled = disableActions;
      closeBtn.addEventListener('click', () => {
        submitClose(position.mint, position.qty);
      });
      trimBtn.addEventListener('click', () => {
        submitClose(position.mint, position.qty * 0.5);
      });
      actionsCell.appendChild(closeBtn);
      actionsCell.appendChild(trimBtn);
      rowsBody.appendChild(row);
    });
    renderBudget();
  }
  const sortAndRender = attachSortableTable(table, positionsRows, render, 'positions-sort');
  function updatePositions(list) {
    positionsRows.splice(0, positionsRows.length, ...list.map((pos) => ({...pos})));
    if (sortAndRender) sortAndRender(); else render();
  }
  async function submitClose(mint, qty) {
    try {
      await fetch(ENDPOINTS.closePosition(mint, qty), {method: 'POST', headers: {'Content-Type': 'application/json'}});
    } catch (err) {
      console.error('close failed', err);
    }
  }
  async function loadSnapshot() {
    statusNode.textContent = 'Loading positions…';
    try {
      const data = await safeFetchJson(ENDPOINTS.positionsSnapshot, 'positions', errorNode, {headers: {Accept: 'application/json'}});
      if (Array.isArray(data)) {
        const mapped = data.map((row) => ({
          mint: row.mint || row.token || '—',
          qty: Number(row.qty || row.quantity || 0),
          avg_cost: Number(row.avg_cost || row.avg || 0),
          mark: Number(row.mark || row.price || 0),
          ue_pnl: Number(row.unrealized_pnl || row.ue_pnl || 0),
          realized_pnl: Number(row.realized_pnl || 0),
          risk: Number(row.risk_weight || row.risk || 0)
        }));
        updatePositions(mapped);
        hydration.positions = true;
        statusNode.textContent = 'Live';
      }
    } catch (err) {
      statusNode.textContent = 'Positions snapshot failed';
    }
  }
  let wsRef = null;
  function startStream() {
    if (wsRef) wsRef.close();
    wsRef = createWsConnection({
      url: ENDPOINTS.portfolioStream,
      panelId: 'positions',
      errorNode,
      onStatus: (status) => {
        if (status === 'connected') {
          statusNode.textContent = 'Live';
        } else if (!state.positionsPaused) {
          statusNode.textContent = 'Backoff — optimistic UI';
        }
      },
      onMessage: (payload) => {
        if (state.positionsPaused) return;
        const parsed = safeJsonParse(payload, 'positions', errorNode);
        const rows = unwrapStreamPayload(parsed, ['positions', 'portfolio', 'updates']);
        rows.forEach((row) => {
          const mint = row.mint || row.token;
          const position = {
            mint: mint || '—',
            qty: Number(row.qty || row.quantity || row.size || 0),
            avg_cost: Number(row.avg_cost || row.avg || row.cost_basis || 0),
            mark: Number(row.mark || row.price || row.mark_price || 0),
            ue_pnl: Number(row.unrealized_pnl || row.ue_pnl || row.unrealized || 0),
            realized_pnl: Number(row.realized_pnl || row.realized || 0),
            risk: Number(row.risk_weight || row.risk || 0)
          };
          const index = positionsRows.findIndex((p) => p.mint === position.mint);
          if (index >= 0) {
            positionsRows[index] = position;
          } else {
            positionsRows.push(position);
          }
        });
        hydration.positions = true;
        updatePositions(positionsRows);
      }
    });
  }
  pauseBtn.addEventListener('click', () => {
    state.positionsPaused = !state.positionsPaused;
    pauseBtn.textContent = state.positionsPaused ? 'Resume' : 'Pause';
    if (state.positionsPaused) {
      if (wsRef) wsRef.close();
      statusNode.textContent = 'Paused';
    } else {
      loadSnapshot().then(() => startStream());
    }
  });
  doc.addEventListener('run-state-update', renderBudget);
  renderBudget();
  loadSnapshot().then(() => startStream());
  window.setInterval(() => {
    if (!state.positionsPaused) {
      loadSnapshot();
    }
  }, 5000);
}
    function setupPnlPanel() {
      const panel = doc.getElementById('panel-pnl');
      if (!panel) return;
      const statusNode = panel.querySelector('[data-role="status"]');
      const metricsGrid = panel.querySelector('[data-role="metrics"]');
      const errorNode = panel.querySelector('[data-role="error"]');
      const windowSelect = panel.querySelector('select[data-control="window"]');
      const pauseBtn = panel.querySelector('button[data-control="pause"]');
      let wsRef = null;
      function render(pnlData, riskData, previousRisk) {
        metricsGrid.innerHTML = '';
        if (!pnlData && !riskData) {
          statusNode.textContent = 'Waiting for data…';
          hydration.pnl = true;
          return;
        }
        hydration.pnl = true;
        if (pnlData) {
          const pnlEntry = doc.createElement('div');
          pnlEntry.className = 'header-card';
          pnlEntry.innerHTML = `
            <dt>PnL (${windowSelect.value === '3600' ? '1h' : '24h'})</dt>
            <dd>${formatCurrency(pnlData.realized || 0)} · Unrealized ${formatCurrency(pnlData.unrealized || 0)}</dd>
          `;
          metricsGrid.appendChild(pnlEntry);
          const volEntry = doc.createElement('div');
          volEntry.className = 'header-card';
          volEntry.innerHTML = `<dt>Turnover</dt><dd>${formatCurrency(pnlData.turnover || 0)}</dd>`;
          metricsGrid.appendChild(volEntry);
        }
        if (riskData) {
          const utilEntry = doc.createElement('div');
          utilEntry.className = 'header-card';
          utilEntry.innerHTML = `<dt>Utilization</dt><dd>${formatPercent(riskData.utilization || 0)} of ${formatPercent(riskData.max_allocation || 0)}</dd>`;
          metricsGrid.appendChild(utilEntry);
          const varEntry = doc.createElement('div');
          varEntry.className = 'header-card';
          varEntry.innerHTML = `<dt>VaR Proxy</dt><dd>${formatCurrency(riskData.var_proxy || 0)}</dd>`;
          metricsGrid.appendChild(varEntry);
          const prevTolerance = previousRisk ? maybeNumber(previousRisk.risk_tolerance) : null;
          const nextTolerance = maybeNumber(riskData.risk_tolerance);
          const prevMultiplier = previousRisk ? maybeNumber(previousRisk.risk_multiplier) : null;
          const nextMultiplier = maybeNumber(riskData.risk_multiplier);
          const changes = [];
          if (nextTolerance !== null && prevTolerance !== null && nextTolerance !== prevTolerance) {
            changes.push(`RISK_TOLERANCE ${formatNumber(prevTolerance, 2)} → ${formatNumber(nextTolerance, 2)}`);
          }
          if (nextMultiplier !== null && prevMultiplier !== null && nextMultiplier !== prevMultiplier) {
            changes.push(`RISK_MULTIPLIER ${formatNumber(prevMultiplier, 2)} → ${formatNumber(nextMultiplier, 2)}`);
          }
          if (changes.length) {
            const banner = doc.createElement('div');
            banner.className = 'banner warning';
            banner.textContent = `Risk updated: ${changes.join(' · ')}`;
            metricsGrid.appendChild(banner);
          } else if (riskData.tolerance_change) {
            const banner = doc.createElement('div');
            banner.className = 'banner warning';
            banner.textContent = `Risk updated: ${riskData.tolerance_change}`;
            metricsGrid.appendChild(banner);
          }
        }
        statusNode.textContent = 'Live';
      }
      async function loadSnapshot() {
        if (state.pnlPaused) return;
        statusNode.textContent = 'Loading…';
        try {
          const windowParam = windowSelect.value;
          const [pnl, risk] = await Promise.all([
            safeFetchJson(ENDPOINTS.pnlSnapshot(windowParam), 'pnl', errorNode, {headers: {Accept: 'application/json'}}).catch(() => null),
            safeFetchJson(ENDPOINTS.riskSnapshot, 'risk', errorNode, {headers: {Accept: 'application/json'}}).catch(() => null)
          ]);
          const previousRisk = state.lastRiskState;
          state.pnlMetrics = {pnl, risk};
          if (risk) {
            state.lastRiskState = risk;
          }
          render(pnl, risk, previousRisk);
          hydration.pnl = true;
        } catch (err) {
          statusNode.textContent = 'PnL snapshot failed';
        }
      }
      function startStream() {
        if (wsRef) wsRef.close();
        wsRef = createWsConnection({
          url: ENDPOINTS.riskStream,
          panelId: 'risk',
          errorNode,
          onStatus: (status) => {
            if (status === 'connected') {
              if (!state.pnlPaused) statusNode.textContent = 'Live';
            } else if (!state.pnlPaused) {
              statusNode.textContent = 'Backoff — optimistic UI';
            }
          },
          onMessage: (payload) => {
            if (state.pnlPaused) return;
            const parsed = safeJsonParse(payload, 'risk', errorNode);
            const frames = unwrapStreamPayload(parsed, ['risk', 'metrics', 'state']);
            frames.forEach((data) => {
              if (!data || typeof data !== 'object') return;
              const previous = state.lastRiskState;
              state.lastRiskState = data;
              state.pnlMetrics = state.pnlMetrics || {};
              state.pnlMetrics.risk = data;
              render(state.pnlMetrics ? state.pnlMetrics.pnl : null, data, previous);
            });
          }
        });
      }
      windowSelect.addEventListener('change', () => {
        state.pnlWindow = Number(windowSelect.value);
        loadSnapshot();
      });
      pauseBtn.addEventListener('click', () => {
        state.pnlPaused = !state.pnlPaused;
        pauseBtn.textContent = state.pnlPaused ? 'Resume' : 'Pause';
        if (state.pnlPaused) {
          if (wsRef) wsRef.close();
          statusNode.textContent = 'Paused';
        } else {
          loadSnapshot();
          startStream();
        }
      });
      loadSnapshot().then(startStream);
      window.setInterval(() => {
        if (!state.pnlPaused) loadSnapshot();
      }, 15000);
    }
    function setupRuntimePanel() {
      const panel = doc.getElementById('panel-runtime');
      if (!panel) return;
      const statusNode = panel.querySelector('[data-role="status"]');
      const metricsGrid = panel.querySelector('[data-role="metrics"]');
      const errorNode = panel.querySelector('[data-role="error"]');
      const pauseBtn = panel.querySelector('button[data-control="pause"]');
      let wsRef = null;
      function flattenNumericMetrics(source, prefix = '') {
        const result = {};
        if (!source || typeof source !== 'object') return result;
        Object.entries(source).forEach(([key, value]) => {
          if (value === null || value === undefined) return;
          const nextKey = prefix ? `${prefix}.${key}` : key;
          if (typeof value === 'number') {
            result[nextKey] = value;
          } else if (!Array.isArray(value) && typeof value === 'object') {
            Object.assign(result, flattenNumericMetrics(value, nextKey));
          }
        });
        return result;
      }
      function render(providers, metrics) {
        metricsGrid.innerHTML = '';
        if (!providers && !metrics) {
          statusNode.textContent = 'Waiting for metrics…';
          annotateRateLimitPanels({});
          hydration.runtime = true;
          return;
        }
        hydration.runtime = true;
        if (Array.isArray(providers)) {
          providers.forEach((provider) => {
            const card = doc.createElement('div');
            card.className = 'header-card';
            const twoXX = provider['2xx'] !== undefined ? provider['2xx'] : provider.success;
            const four29 = provider['429'] !== undefined ? provider['429'] : provider.rate_limited;
            card.innerHTML = `<dt>${provider.name || provider.provider}</dt><dd>${twoXX || 0} ×2xx · ${four29 || 0} ×429</dd>`;
            metricsGrid.appendChild(card);
          });
        }
        if (metrics && typeof metrics === 'object') {
          Object.entries(metrics).forEach(([key, value]) => {
            if (typeof value !== 'number') return;
            const card = doc.createElement('div');
            card.className = 'header-card';
            card.innerHTML = `<dt>${key}</dt><dd>${formatNumber(value, 2)}</dd>`;
            metricsGrid.appendChild(card);
          });
        }
        const runState = state.runState;
        if (runState && runState.rpc_backoff) {
          const card = doc.createElement('div');
          card.className = 'header-card';
          card.innerHTML = `<dt>RPC Backoff</dt><dd>${runState.rpc_backoff}</dd>`;
          metricsGrid.appendChild(card);
        }
        if (runState && runState.rps_limits) {
          const limitsText = Array.isArray(runState.rps_limits) ? runState.rps_limits.join(', ') : runState.rps_limits;
          if (limitsText) {
            const card = doc.createElement('div');
            card.className = 'header-card';
            card.innerHTML = `<dt>RPS Limits</dt><dd>${limitsText}</dd>`;
            metricsGrid.appendChild(card);
          }
        }
        statusNode.textContent = 'Live';
        annotateRateLimitPanels(metrics || {});
      }
      async function loadSnapshot() {
        if (state.runtimePaused) return;
        statusNode.textContent = 'Loading…';
        try {
          const [health, providers] = await Promise.all([
            safeFetchJson(ENDPOINTS.health, 'runtime-health', errorNode, {headers: {Accept: 'application/json'}}).catch(() => null),
            safeFetchJson(ENDPOINTS.providerStatus, 'providers', errorNode, {headers: {Accept: 'application/json'}})
          ]);
          const numeric = flattenNumericMetrics(health || {});
          const existing = state.runtimeMetrics && state.runtimeMetrics.metrics ? {...state.runtimeMetrics.metrics} : {};
          const merged = {...existing, ...numeric};
          state.runtimeMetrics = {providers: providers || [], metrics: merged};
          render(state.runtimeMetrics.providers, merged);
        } catch (err) {
          statusNode.textContent = 'Provider snapshot failed';
        }
      }
      function startStream() {
        if (wsRef) wsRef.close();
        wsRef = createWsConnection({
          url: ENDPOINTS.metricsStream,
          panelId: 'metrics',
          errorNode,
          onStatus: (status) => {
            if (status === 'connected') {
              if (!state.runtimePaused) statusNode.textContent = 'Live';
            } else if (!state.runtimePaused) {
              statusNode.textContent = 'Backoff — optimistic UI';
            }
          },
          onMessage: (payload) => {
            if (state.runtimePaused) return;
            const parsed = safeJsonParse(payload, 'metrics', errorNode);
            const frames = unwrapStreamPayload(parsed, ['metrics', 'data', 'providers']);
            frames.forEach((data) => {
              if (!data || typeof data !== 'object') return;
              state.runtimeMetrics = state.runtimeMetrics || {providers: [], metrics: {}};
              if (Array.isArray(data.providers)) {
                state.runtimeMetrics.providers = data.providers;
              }
              const numeric = flattenNumericMetrics(data.metrics || data);
              if (Object.keys(numeric).length) {
                const merged = {...(state.runtimeMetrics.metrics || {}), ...numeric};
                state.runtimeMetrics.metrics = merged;
                render(state.runtimeMetrics.providers || [], merged);
                const any429 = Object.keys(merged).some((key) => key.toLowerCase().includes('429') && Number(merged[key]) > 0);
                if (any429) {
                  statusNode.textContent = 'Rate limited — observing backoff';
                }
              } else if (Array.isArray(data.providers)) {
                render(state.runtimeMetrics.providers || [], state.runtimeMetrics.metrics || {});
              }
            });
          }
        });
      }
      pauseBtn.addEventListener('click', () => {
        state.runtimePaused = !state.runtimePaused;
        pauseBtn.textContent = state.runtimePaused ? 'Resume' : 'Pause';
        if (state.runtimePaused) {
          if (wsRef) wsRef.close();
          statusNode.textContent = 'Paused';
        } else {
          loadSnapshot();
          startStream();
        }
      });
      loadSnapshot().then(startStream);
      window.setInterval(() => {
        if (!state.runtimePaused) loadSnapshot();
      }, 20000);
    }
    function setupLogsPanel() {
      const panel = doc.getElementById('panel-logs');
      if (!panel) return;
      const statusNode = panel.querySelector('[data-role="status"]');
      const list = panel.querySelector('[data-role="list"]');
      const errorNode = panel.querySelector('[data-role="error"]');
      const pauseBtn = panel.querySelector('button[data-control="pause"]');
      let wsRef = null;
      let currentRunId = state.runState && state.runState.run_id ? String(state.runState.run_id) : null;
      const snapshotUrl = () => ENDPOINTS.logsSnapshot(currentRunId);
      const streamUrl = () => ENDPOINTS.logsStream(currentRunId);
      function renderLine(entry) {
        const div = doc.createElement('div');
        div.className = `log-line ${entry.level}`;
        div.textContent = `[${entry.time.label}] ${entry.message}`;
        div.title = entry.time.utc;
        div.addEventListener('click', () => {
          if (entry.mint) {
            selectedMintStore.set(entry.mint);
          }
        });
        list.appendChild(div);
        if (list.children.length > 500) {
          list.removeChild(list.firstChild);
        }
      }
      async function loadSnapshot() {
        statusNode.textContent = 'Loading logs…';
        try {
          const data = await safeFetchJson(snapshotUrl(), 'logs', errorNode, {headers: {Accept: 'application/json'}});
          list.innerHTML = '';
          if (Array.isArray(data)) {
            data.forEach((row) => {
              const time = formatTimestamp(row.ts || row.timestamp || Date.now());
              renderLine({
                level: (row.level || 'info').toLowerCase(),
                message: row.message || row.msg || JSON.stringify(row),
                mint: row.mint,
                time
              });
            });
            hydration.logs = true;
            statusNode.textContent = 'Live';
          }
        } catch (err) {
          statusNode.textContent = 'Log snapshot failed';
        }
      }
      function startStream() {
        if (wsRef) wsRef.close();
        wsRef = createWsConnection({
          url: streamUrl(),
          panelId: 'logs',
          errorNode,
          onStatus: (status) => {
            if (status === 'connected') {
              statusNode.textContent = 'Live';
            } else if (!state.logsPaused) {
              statusNode.textContent = 'Backoff — optimistic UI';
            }
          },
          onMessage: (payload) => {
            if (state.logsPaused) return;
            const data = safeJsonParse(payload, 'logs', errorNode);
            const rows = Array.isArray(data) ? data : [data];
            rows.forEach((row) => {
              const time = formatTimestamp(row.ts || row.timestamp || Date.now());
              renderLine({
                level: (row.level || 'info').toLowerCase(),
                message: row.message || row.msg || JSON.stringify(row),
                mint: row.mint,
                time
              });
            });
            hydration.logs = true;
          }
        });
      }
      pauseBtn.addEventListener('click', () => {
        state.logsPaused = !state.logsPaused;
        pauseBtn.textContent = state.logsPaused ? 'Resume' : 'Pause';
        if (state.logsPaused) {
          if (wsRef) wsRef.close();
          statusNode.textContent = 'Paused';
        } else {
          loadSnapshot().then(() => {
            if (!state.logsPaused) startStream();
          });
        }
      });
      const handleRunStateUpdate = (event) => {
        const detail = event.detail || {};
        const nextRunId = detail.run_id ? String(detail.run_id) : null;
        if (nextRunId === currentRunId) return;
        currentRunId = nextRunId;
        if (state.logsPaused) return;
        if (wsRef) wsRef.close();
        loadSnapshot().then(() => {
          if (!state.logsPaused) startStream();
        });
      };
      doc.addEventListener('run-state-update', handleRunStateUpdate);
      loadSnapshot().then(startStream);
    }
    function setupSelfCheck() {
      const button = doc.getElementById('self-check-btn');
      const statusLabel = doc.getElementById('self-check-status');
      if (!button) return;
      let running = false;
      async function runSelfCheck() {
        if (running) return;
        running = true;
        button.disabled = true;
        statusLabel.textContent = 'Self-Check running (30s)…';
        const start = Date.now();
        const originalMint = selectedMintStore.get();
        const testMint = 'SELF_CHECK_MINT';
        selectedMintStore.set(testMint);
        await new Promise((resolve) => setTimeout(resolve, 200));
        const mintPropagation = state.selectedMint === testMint;
        selectedMintStore.set(originalMint || null);
        const interval = window.setInterval(() => {
          const elapsed = Math.floor((Date.now() - start) / 1000);
          statusLabel.textContent = `Self-Check running (${elapsed}s)…`;
        }, 1000);
        await new Promise((resolve) => setTimeout(resolve, 30000));
        window.clearInterval(interval);
        const panelsOk = Object.values(hydration).every(Boolean);
        const runtimeMetrics = state.runtimeMetrics || {};
        const providerStatsOk = Array.isArray(runtimeMetrics.providers) && runtimeMetrics.providers.some((provider) => {
          if (!provider) return false;
          const has2xx = Object.prototype.hasOwnProperty.call(provider, '2xx') || Object.prototype.hasOwnProperty.call(provider, 'success');
          const has429 = Object.prototype.hasOwnProperty.call(provider, '429') || Object.prototype.hasOwnProperty.call(provider, 'rate_limited');
          return has2xx && has429;
        });
        const metricsMap = runtimeMetrics.metrics && typeof runtimeMetrics.metrics === 'object' ? runtimeMetrics.metrics : null;
        const rateMetricsOk = metricsMap
          ? Object.keys(metricsMap).some((key) => key.toLowerCase().includes('429'))
          : true;
        const pnlOk = (() => {
          if (state.pnlMetrics && state.pnlMetrics.pnl) return true;
          const mock = {qty: 1, fill: 1.2, cost: 1.0};
          const pnl = mock.qty * (mock.fill - mock.cost);
          return Number.isFinite(pnl);
        })();
        const mintOk = mintPropagation;
        const runtimeCountsOk = providerStatsOk && rateMetricsOk;
        const resultOk = panelsOk && pnlOk && mintOk && runtimeCountsOk;
        statusLabel.textContent = resultOk ? 'Self-Check pass' : 'Self-Check failed';
        running = false;
        button.disabled = false;
      }
      button.addEventListener('click', runSelfCheck);
    }
    function init() {
      setupRunHeader();
      setupDiscoveryPanel();
      setupTokenPanel();
      setupAgentPanel();
      setupPlannerPanel();
      setupOrdersPanel();
      setupPositionsPanel();
      setupPnlPanel();
      setupRuntimePanel();
      setupLogsPanel();
      setupSelfCheck();
      console.log(UI_READY_MESSAGE);
    }
    document.addEventListener('DOMContentLoaded', init);
  })();
  </script>
</body>
</html>
