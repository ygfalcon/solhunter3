<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SolHunter · Live Console</title>
    <style>
        :root {
            color-scheme: dark;
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            --bg: #05070c;
            --panel-bg: rgba(13, 17, 27, 0.92);
            --panel-border: rgba(88, 166, 255, 0.25);
            --panel-border-hover: rgba(88, 166, 255, 0.45);
            --panel-shadow: 0 24px 48px rgba(0, 0, 0, 0.55);
            --text: #f0f6ff;
            --muted: #94a3b8;
            --accent: #4f9cff;
            --success: #3fb950;
            --warning: #facc15;
            --danger: #ef4444;
            --surface: rgba(30, 41, 59, 0.65);
            --pill-bg: rgba(148, 163, 184, 0.18);
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            background: radial-gradient(circle at top left, rgba(79, 156, 255, 0.18), transparent 55%), var(--bg);
            color: var(--text);
            min-height: 100vh;
        }
        a {
            color: var(--accent);
        }
        #app {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header.run-header {
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(14px);
            background: linear-gradient(135deg, rgba(13, 17, 27, 0.92), rgba(13, 17, 27, 0.75));
            border-bottom: 1px solid rgba(88, 166, 255, 0.35);
            box-shadow: 0 18px 36px rgba(5, 7, 12, 0.6);
            padding: 20px clamp(16px, 3vw, 32px);
        }
        header.run-header .header-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
        }
        header.run-header h1 {
            margin: 0;
            font-size: 1.35rem;
            font-weight: 600;
        }
        header.run-header .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 999px;
            font-size: 0.82rem;
            background: var(--pill-bg);
            color: var(--text);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        header.run-header .health-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            font-weight: 600;
        }
        header.run-header .health-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--warning);
            box-shadow: 0 0 12px rgba(250, 204, 21, 0.4);
        }
        header.run-header .health-dot.ok {
            background: var(--success);
            box-shadow: 0 0 12px rgba(63, 185, 80, 0.45);
        }
        header.run-header .health-dot.warn {
            background: var(--warning);
            box-shadow: 0 0 12px rgba(250, 204, 21, 0.55);
        }
        header.run-header .health-dot.danger {
            background: var(--danger);
            box-shadow: 0 0 12px rgba(239, 68, 68, 0.55);
        }
        header.run-header .actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        button, .button {
            font-family: inherit;
            font-size: 0.9rem;
            background: rgba(79, 156, 255, 0.12);
            color: var(--text);
            border: 1px solid rgba(79, 156, 255, 0.4);
            border-radius: 10px;
            padding: 8px 14px;
            cursor: pointer;
            transition: background 0.2s ease, border 0.2s ease;
        }
        button:hover, .button:hover {
            background: rgba(79, 156, 255, 0.22);
            border-color: rgba(79, 156, 255, 0.6);
        }
        button:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }
        .header-grid {
            margin-top: 18px;
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }
        .header-card {
            background: rgba(15, 23, 42, 0.85);
            padding: 12px 16px;
            border-radius: 14px;
            border: 1px solid rgba(88, 166, 255, 0.18);
            display: grid;
            gap: 6px;
        }
        .header-card .label {
            text-transform: uppercase;
            font-size: 0.72rem;
            letter-spacing: 0.08em;
            color: var(--muted);
        }
        .header-card .value {
            font-size: 1.05rem;
            font-weight: 600;
        }
        .console-layout {
            display: grid;
            grid-template-columns: minmax(320px, 360px) 1fr;
            gap: 24px;
            padding: 24px clamp(16px, 3vw, 32px) 48px;
            flex: 1;
        }
        .side-rail, .main-panels {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }
        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 18px;
            padding: 20px;
            box-shadow: var(--panel-shadow);
            display: flex;
            flex-direction: column;
            min-height: 200px;
        }
        .panel:hover {
            border-color: var(--panel-border-hover);
        }
        .panel[data-state="error"] {
            border-color: rgba(239, 68, 68, 0.75);
        }
        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 16px;
        }
        .panel-header h2 {
            margin: 0;
            font-size: 1.12rem;
            font-weight: 600;
        }
        .panel-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            font-size: 0.8rem;
        }
        .panel-controls .window-select {
            display: inline-flex;
            gap: 4px;
            border-radius: 999px;
            padding: 2px;
            background: rgba(148, 163, 184, 0.12);
        }
        .panel-controls .window-select button {
            border-radius: 999px;
            padding: 6px 10px;
            border: none;
            background: transparent;
            font-size: 0.78rem;
        }
        .panel-controls .window-select button.active {
            background: rgba(79, 156, 255, 0.25);
            border: 1px solid rgba(79, 156, 255, 0.6);
        }
        .panel-status {
            font-size: 0.82rem;
            color: var(--muted);
            margin-bottom: 8px;
        }
        .panel-status[data-level="error"] {
            color: var(--danger);
        }
        .panel-status[data-level="warn"] {
            color: var(--warning);
        }
        .panel-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow: hidden;
        }
        .table-wrap {
            overflow: auto;
            border-radius: 12px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 100%;
        }
        th, td {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.12);
            text-align: left;
            font-size: 0.86rem;
        }
        th {
            font-size: 0.78rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--muted);
            cursor: pointer;
        }
        th.sort-asc::after {
            content: "▲";
            margin-left: 6px;
            font-size: 0.65rem;
        }
        th.sort-desc::after {
            content: "▼";
            margin-left: 6px;
            font-size: 0.65rem;
        }
        tr:hover td {
            background: rgba(79, 156, 255, 0.08);
        }
        .timeline {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 520px;
            overflow-y: auto;
            padding-right: 6px;
        }
        .timeline-item {
            padding: 12px 14px;
            border-radius: 12px;
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid rgba(88, 166, 255, 0.18);
            display: grid;
            gap: 6px;
            cursor: pointer;
        }
        .timeline-item.selected {
            border-color: rgba(79, 156, 255, 0.7);
            box-shadow: 0 0 0 1px rgba(79, 156, 255, 0.35);
        }
        .timeline-item .meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            font-size: 0.78rem;
            color: var(--muted);
        }
        .badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 0.72rem;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            background: rgba(148, 163, 184, 0.18);
            color: var(--muted);
        }
        .badge.live {
            background: rgba(63, 185, 80, 0.18);
            color: var(--success);
        }
        .badge.warn {
            background: rgba(250, 204, 21, 0.18);
            color: var(--warning);
        }
        .badge.danger {
            background: rgba(239, 68, 68, 0.18);
            color: var(--danger);
        }
        .detail-grid {
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }
        .detail-card {
            background: rgba(30, 41, 59, 0.55);
            border-radius: 12px;
            padding: 14px 16px;
            border: 1px solid rgba(88, 166, 255, 0.18);
            display: grid;
            gap: 4px;
        }
        .detail-card .label {
            font-size: 0.75rem;
            color: var(--muted);
            letter-spacing: 0.04em;
            text-transform: uppercase;
        }
        .detail-card .value {
            font-size: 0.95rem;
            font-weight: 600;
        }
        .sparkline {
            width: 100%;
            height: 56px;
        }
        .logs-list {
            max-height: 360px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .log-entry {
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(30, 41, 59, 0.55);
            border: 1px solid rgba(88, 166, 255, 0.16);
            font-size: 0.78rem;
            line-height: 1.4;
            cursor: pointer;
        }
        .log-entry[data-level="ERROR"] {
            border-color: rgba(239, 68, 68, 0.65);
        }
        .log-entry[data-level="WARN"] {
            border-color: rgba(250, 204, 21, 0.55);
        }
        .empty-state {
            text-align: center;
            color: var(--muted);
            padding: 32px 12px;
            font-size: 0.9rem;
        }
        .error-banner {
            background: rgba(250, 204, 21, 0.12);
            border: 1px solid rgba(250, 204, 21, 0.35);
            color: var(--warning);
            border-radius: 12px;
            padding: 12px 14px;
            font-size: 0.85rem;
        }
        .link-copy {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: var(--accent);
            cursor: pointer;
        }
        @media (max-width: 1200px) {
            .console-layout {
                grid-template-columns: 1fr;
            }
            .side-rail {
                order: 2;
            }
            .main-panels {
                order: 1;
            }
        }
        @media (max-width: 640px) {
            header.run-header .header-top {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
<div id="app">
    <header class="run-header panel" data-panel-key="run-header-safety-state">
        <div class="panel-header">
            <div class="header-top">
                <h1>Live Console · Production Run</h1>
                <div class="pill" id="workflow-pill">Workflow</div>
                <div class="pill" id="mode-pill">Mode</div>
                <div class="pill" id="canary-pill" hidden>Live (Canary)</div>
                <div class="health-indicator" id="health-indicator">
                    <span class="health-dot warn"></span>
                    <span class="label">Health pending…</span>
                </div>
            </div>
            <div class="actions">
                <button type="button" data-action="copy-env">Copy env</button>
                <button type="button" data-action="self-check">Run Self-Check</button>
                <div class="panel-controls" data-controls>
                    <button type="button" data-action="pause">Pause</button>
                    <button type="button" data-action="resume">Resume</button>
                    <div class="window-select" data-window-select>
                        <button type="button" data-window="5">5s</button>
                        <button type="button" data-window="15" class="active">15s</button>
                        <button type="button" data-window="60">60s</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="panel-status" data-role="status">Awaiting run state…</div>
        <div class="header-grid" id="run-header-grid">
            <div class="header-card">
                <div class="label">Keypair fingerprint</div>
                <div class="value" id="keypair-fingerprint">—</div>
                <div class="label">KEYPAIR_PATH</div>
                <div class="value" id="keypair-path">—</div>
            </div>
            <div class="header-card">
                <div class="label">Budget remaining</div>
                <div class="value" id="budget-remaining">—</div>
                <div class="label">Risk current</div>
                <div class="value" id="risk-current">—</div>
            </div>
            <div class="header-card">
                <div class="label">Throttle / Backoff</div>
                <div class="value" id="throttle-info">—</div>
                <div class="label">RPC Backoff</div>
                <div class="value" id="rpc-backoff">—</div>
            </div>
            <div class="header-card">
                <div class="label">Event Bus</div>
                <div class="value" id="event-bus-info">—</div>
                <div class="label">Redis</div>
                <div class="value" id="redis-info">—</div>
            </div>
        </div>
        <div class="panel-body" data-role="content"></div>
    </header>
    <main class="console-layout">
        <aside class="side-rail">
            <section class="panel" data-panel-key="discovery-stream">
                <div class="panel-header">
                    <h2>Discovery Stream (Mint &amp; Mempool)</h2>
                    <div class="panel-controls" data-controls>
                        <button type="button" data-action="pause">Pause</button>
                        <button type="button" data-action="resume">Resume</button>
                        <div class="window-select" data-window-select>
                            <button type="button" data-window="5">5s</button>
                            <button type="button" data-window="15" class="active">15s</button>
                            <button type="button" data-window="60">60s</button>
                        </div>
                    </div>
                </div>
                <div class="panel-status" data-role="status">Streaming mint discovery…</div>
                <div class="panel-body" data-role="content">
                    <div class="timeline" id="discovery-timeline"></div>
                </div>
            </section>
            <section class="panel" data-panel-key="runtime-health-rate-limits">
                <div class="panel-header">
                    <h2>Runtime Health &amp; Rate Limits</h2>
                    <div class="panel-controls" data-controls>
                        <button type="button" data-action="pause">Pause</button>
                        <button type="button" data-action="resume">Resume</button>
                        <div class="window-select" data-window-select>
                            <button type="button" data-window="5">5s</button>
                            <button type="button" data-window="15" class="active">15s</button>
                            <button type="button" data-window="60">60s</button>
                        </div>
                    </div>
                </div>
                <div class="panel-status" data-role="status">Awaiting provider metrics…</div>
                <div class="panel-body" data-role="content">
                    <div class="detail-grid" id="runtime-health-cards"></div>
                    <div class="error-banner" id="rate-limit-banner" hidden></div>
                </div>
            </section>
            <section class="panel" data-panel-key="structured-logs-live">
                <div class="panel-header">
                    <h2>Structured Logs (Live)</h2>
                    <div class="panel-controls" data-controls>
                        <button type="button" data-action="pause">Pause</button>
                        <button type="button" data-action="resume">Resume</button>
                        <div class="window-select" data-window-select>
                            <button type="button" data-window="5">5s</button>
                            <button type="button" data-window="15" class="active">15s</button>
                            <button type="button" data-window="60">60s</button>
                        </div>
                    </div>
                </div>
                <div class="panel-status" data-role="status">Tailing latest logs…</div>
                <div class="panel-body" data-role="content">
                    <div class="logs-list" id="logs-list"></div>
                </div>
            </section>
        </aside>
        <section class="main-panels">
            <section class="panel" data-panel-key="token-deep-view">
                <div class="panel-header">
                    <h2>Token Deep View</h2>
                    <div class="panel-controls" data-controls>
                        <button type="button" data-action="pause">Pause</button>
                        <button type="button" data-action="resume">Resume</button>
                        <div class="window-select" data-window-select>
                            <button type="button" data-window="5">5s</button>
                            <button type="button" data-window="15" class="active">15s</button>
                            <button type="button" data-window="60">60s</button>
                        </div>
                    </div>
                </div>
                <div class="panel-status" data-role="status">Pick a discovery candidate.</div>
                <div class="panel-body" data-role="content">
                    <div class="error-banner" id="token-warning" hidden></div>
                    <div class="detail-grid" id="token-details"></div>
                    <svg class="sparkline" id="token-sparkline"></svg>
                    <div class="detail-grid" id="depth-details"></div>
                </div>
            </section>
            <section class="panel" data-panel-key="agent-swarm-timeline">
                <div class="panel-header">
                    <h2>Agent Swarm Timeline</h2>
                    <div class="panel-controls" data-controls>
                        <button type="button" data-action="pause">Pause</button>
                        <button type="button" data-action="resume">Resume</button>
                        <div class="window-select" data-window-select>
                            <button type="button" data-window="5">5s</button>
                            <button type="button" data-window="15" class="active">15s</button>
                            <button type="button" data-window="60">60s</button>
                        </div>
                    </div>
                </div>
                <div class="panel-status" data-role="status">Waiting for agent emissions…</div>
                <div class="panel-body" data-role="content">
                    <div class="timeline" id="agent-timeline"></div>
                </div>
            </section>
            <section class="panel" data-panel-key="trade-planner-routing">
                <div class="panel-header">
                    <h2>Trade Planner &amp; Routing</h2>
                    <div class="panel-controls" data-controls>
                        <button type="button" data-action="pause">Pause</button>
                        <button type="button" data-action="resume">Resume</button>
                        <div class="window-select" data-window-select>
                            <button type="button" data-window="5">5s</button>
                            <button type="button" data-window="15" class="active">15s</button>
                            <button type="button" data-window="60">60s</button>
                        </div>
                    </div>
                </div>
                <div class="panel-status" data-role="status">Planner idle.</div>
                <div class="panel-body" data-role="content">
                    <div class="detail-grid" id="plan-details"></div>
                    <div class="detail-card" id="dry-run-card" hidden>
                        <div class="label">Dry-run preview</div>
                        <div class="value" id="dry-run-result">—</div>
                        <div class="label">Slippage simulation</div>
                        <div class="value" id="dry-run-slippage">—</div>
                    </div>
                </div>
            </section>
            <section class="panel" data-panel-key="orders-fills-slippage">
                <div class="panel-header">
                    <h2>Orders, Fills &amp; Slippage</h2>
                    <div class="panel-controls" data-controls>
                        <button type="button" data-action="pause">Pause</button>
                        <button type="button" data-action="resume">Resume</button>
                        <div class="window-select" data-window-select>
                            <button type="button" data-window="5">5s</button>
                            <button type="button" data-window="15" class="active">15s</button>
                            <button type="button" data-window="60">60s</button>
                        </div>
                    </div>
                </div>
                <div class="panel-status" data-role="status">Collecting fills…</div>
                <div class="panel-body" data-role="content">
                    <div class="detail-grid" id="fills-summary"></div>
                    <div class="table-wrap">
                        <table id="fills-table">
                            <thead>
                                <tr>
                                    <th data-sort-key="ts">Time</th>
                                    <th data-sort-key="mint">Mint</th>
                                    <th data-sort-key="side">Side</th>
                                    <th data-sort-key="qty">Qty</th>
                                    <th data-sort-key="route">Route</th>
                                    <th data-sort-key="quoted">Quoted</th>
                                    <th data-sort-key="realized">Realized</th>
                                    <th data-sort-key="slippage">Slippage (bps)</th>
                                    <th data-sort-key="fees">Fees</th>
                                    <th data-sort-key="status">Status</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </section>
            <section class="panel" data-panel-key="positions-portfolio">
                <div class="panel-header">
                    <h2>Positions &amp; Portfolio</h2>
                    <div class="panel-controls" data-controls>
                        <button type="button" data-action="pause">Pause</button>
                        <button type="button" data-action="resume">Resume</button>
                        <div class="window-select" data-window-select>
                            <button type="button" data-window="5">5s</button>
                            <button type="button" data-window="15" class="active">15s</button>
                            <button type="button" data-window="60">60s</button>
                        </div>
                    </div>
                </div>
                <div class="panel-status" data-role="status">Loading portfolio…</div>
                <div class="panel-body" data-role="content">
                    <div class="detail-grid" id="cash-summary"></div>
                    <div class="table-wrap">
                        <table id="positions-table">
                            <thead>
                                <tr>
                                    <th data-sort-key="mint">Mint</th>
                                    <th data-sort-key="qty">Quantity</th>
                                    <th data-sort-key="avg_cost">Avg Cost</th>
                                    <th data-sort-key="mark">Mark</th>
                                    <th data-sort-key="ue_pnl">Unrealized PnL</th>
                                    <th data-sort-key="realized_pnl">Realized PnL</th>
                                    <th data-sort-key="risk_weight">Risk</th>
                                    <th data-sort-key="actions">Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </section>
            <section class="panel" data-panel-key="pnl-risk-overview">
                <div class="panel-header">
                    <h2>PnL &amp; Risk Overview</h2>
                    <div class="panel-controls" data-controls>
                        <button type="button" data-action="pause">Pause</button>
                        <button type="button" data-action="resume">Resume</button>
                        <div class="window-select" data-window-select>
                            <button type="button" data-window="5">5s</button>
                            <button type="button" data-window="15" class="active">15s</button>
                            <button type="button" data-window="60">60s</button>
                        </div>
                    </div>
                </div>
                <div class="panel-status" data-role="status">Awaiting PnL snapshots…</div>
                <div class="panel-body" data-role="content">
                    <div class="detail-grid" id="pnl-cards"></div>
                    <div class="error-banner" id="risk-banner" hidden></div>
                </div>
            </section>
        </section>
    </main>
</div>
<script id="bootstrap-data" type="application/json">{{ bootstrap_json|safe }}</script>
<script>
(() => {
    const bootstrap = (() => {
        try {
            const raw = document.getElementById('bootstrap-data').textContent || '{}';
            return JSON.parse(raw);
        } catch (err) {
            console.error('Failed to parse bootstrap payload', err);
            return {};
        }
    })();

    const normaliseKey = (name) => String(name || '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');</script>

    const manifestEntries = (() => {
        if (Array.isArray(bootstrap.panels)) {
            return bootstrap.panels;
        }
        if (Array.isArray(bootstrap.live_console_panels)) {
            return bootstrap.live_console_panels;
        }
        if (bootstrap.live_console && Array.isArray(bootstrap.live_console.panels)) {
            return bootstrap.live_console.panels;
        }
        return [];
    })();

    const manifest = new Map();
    manifestEntries.forEach((entry) => {
        if (!entry || typeof entry !== 'object') {
            return;
        }
        const key = normaliseKey(entry.name || entry.panel || entry.key || '');
        if (!key) {
            return;
        }
        manifest.set(key, entry);
    });

    const panelElements = new Map();
    document.querySelectorAll('[data-panel-key]').forEach((node) => {
        const key = normaliseKey(node.dataset.panelKey || node.getAttribute('data-panel-key'));
        if (key) {
            panelElements.set(key, node);
        }
    });

    const resolveManifestField = (entry, field) => {
        if (!entry) {
            return null;
        }
        if (Object.prototype.hasOwnProperty.call(entry, field)) {
            return entry[field];
        }
        const alt = field.replace(/-/g, '_');
        if (Object.prototype.hasOwnProperty.call(entry, alt)) {
            return entry[alt];
        }
        return null;
    };

    const resolveHttpUrl = (url) => {
        if (!url) {
            return null;
        }
        if (url.startsWith('http://') || url.startsWith('https://')) {
            return url;
        }
        return new URL(url, window.location.origin).toString();
    };

    const resolveWsUrl = (url) => {
        if (!url) {
            return null;
        }
        if (url.startsWith('ws://') || url.startsWith('wss://')) {
            return url;
        }
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        return `${protocol}//${window.location.host}${url}`;
    };

    const formatNumber = (value, {digits = 2, prefix = '', suffix = ''} = {}) => {
        if (value === null || value === undefined || Number.isNaN(Number(value))) {
            return '—';
        }
        const number = Number(value);
        const formatted = Math.abs(number) >= 1000
            ? number.toLocaleString(undefined, {maximumFractionDigits: digits})
            : number.toFixed(digits);
        return `${prefix}${formatted}${suffix}`;
    };

    const formatCurrency = (value) => {
        if (value === null || value === undefined || Number.isNaN(Number(value))) {
            return '—';
        }
        return Number(value).toLocaleString(undefined, {
            style: 'currency',
            currency: 'USD',
            maximumFractionDigits: 2,
        });
    };

    const formatPercent = (value) => {
        if (value === null || value === undefined || Number.isNaN(Number(value))) {
            return '—';
        }
        return `${(Number(value) * 100).toFixed(2)}%`;
    };

    const formatClock = (epochMs) => {
        const date = new Date(epochMs || Date.now());
        return {
            label: date.toLocaleTimeString(),
            iso: date.toISOString(),
        };
    };

    const createStore = (initial) => {
        let value = initial;
        const listeners = new Set();
        return {
            get: () => value,
            set: (next) => {
                if (Object.is(value, next)) {
                    return;
                }
                value = next;
                listeners.forEach((listener) => {
                    try {
                        listener(value);
                    } catch (err) {
                        console.error('Store listener failed', err);
                    }
                });
            },
            subscribe: (listener) => {
                listeners.add(listener);
                try {
                    listener(value);
                } catch (err) {
                    console.error('Store subscription failed', err);
                }
                return () => listeners.delete(listener);
            },
        };
    };

    const selectedMintStore = createStore(null);
    const planStore = createStore({mint: null, plan: null});
    const depthStore = createStore(null);

    class PanelController {
        constructor(key, element, {windowed = true} = {}) {
            this.key = key;
            this.element = element;
            this.windowed = windowed;
            this.statusEl = element.querySelector('[data-role="status"]');
            this.contentEl = element.querySelector('[data-role="content"]');
            this.windowSec = Number(localStorage.getItem(this._windowKey())) || 15;
            this.paused = false;
            this.activity = 0;
            this.waiters = new Set();
            this.windowButtons = [];
            this.attachControls();
            this.updateWindowButtons();
        }

        _windowKey() {
            return `solhunter-window-${this.key}`;
        }

        attachControls() {
            const controls = this.element.querySelector('[data-controls]');
            if (!controls) {
                return;
            }
            const pauseBtn = controls.querySelector('[data-action="pause"]');
            const resumeBtn = controls.querySelector('[data-action="resume"]');
            if (pauseBtn) {
                pauseBtn.addEventListener('click', () => this.pause());
            }
            if (resumeBtn) {
                resumeBtn.addEventListener('click', () => this.resume());
            }
            this.windowButtons = Array.from(controls.querySelectorAll('[data-window]'));
            this.windowButtons.forEach((btn) => {
                btn.addEventListener('click', () => {
                    const seconds = Number(btn.dataset.window) || 15;
                    this.setWindow(seconds);
                });
            });
        }

        updateWindowButtons() {
            this.windowButtons.forEach((btn) => {
                const seconds = Number(btn.dataset.window) || 15;
                if (seconds === this.windowSec) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        setWindow(seconds) {
            if (!Number.isFinite(seconds) || seconds <= 0) {
                seconds = 15;
            }
            this.windowSec = seconds;
            localStorage.setItem(this._windowKey(), String(seconds));
            this.updateWindowButtons();
            this.onWindowChange(seconds);
        }

        onWindowChange() {}

        showStatus(text, level = 'info') {
            if (this.statusEl) {
                this.statusEl.textContent = text || '';
                this.statusEl.dataset.level = level;
            }
            if (level === 'error') {
                this.element.dataset.state = 'error';
            } else {
                this.element.dataset.state = '';
            }
        }

        pause() {
            if (this.paused) {
                return;
            }
            this.paused = true;
            this.showStatus('Paused', 'warn');
            this.onPause();
        }

        resume() {
            if (!this.paused) {
                return;
            }
            this.paused = false;
            this.showStatus('Resuming…', 'info');
            this.onResume();
        }

        onPause() {}
        onResume() {}

        markActivity() {
            this.activity += 1;
            if (this.waiters.size) {
                this.waiters.forEach((resolve) => {
                    try {
                        resolve(true);
                    } catch (err) {
                        console.error('Activity resolve failed', err);
                    }
                });
                this.waiters.clear();
            }
        }

        waitForActivity(timeoutMs = 30_000) {
            if (this.activity > 0) {
                return Promise.resolve(true);
            }
            return new Promise((resolve, reject) => {
                const timer = setTimeout(() => {
                    this.waiters.delete(done);
                    reject(new Error(`${this.key} inactive`));
                }, timeoutMs);
                const done = () => {
                    clearTimeout(timer);
                    resolve(true);
                };
                this.waiters.add(done);
            });
        }

        init() {}
    }


    class StreamPanel extends PanelController {
        constructor(key, element, options = {}) {
            super(key, element, options);
            this.snapshotUrl = options.snapshotUrl || null;
            this.streamUrl = options.streamUrl || null;
            this.parse = options.parse || ((payload) => payload);
            this.renderFn = options.render || (() => {});
            this.records = [];
            this.maxRecords = options.maxRecords || 600;
            this.ws = null;
            this.backoffMs = 1500;
            this.maxBackoff = 15000;
            this.optimistic = options.optimistic || 'Reconnecting…';
        }

        init() {
            if (this.snapshotUrl) {
                this.fetchSnapshot().catch((err) => this.showStatus(`Snapshot failed: ${err.message || err}`, 'warn'));
            }
            if (this.streamUrl) {
                this.openStream();
            }
        }

        async fetchSnapshot(urlOverride = null) {
            const url = urlOverride || this.snapshotUrl;
            if (!url) {
                return;
            }
            const httpUrl = resolveHttpUrl(url);
            try {
                const response = await fetch(httpUrl, {cache: 'no-store'});
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const payload = await response.json();
                const data = this.parse(payload, 'snapshot');
                this.acceptData(data, 'snapshot');
                this.showStatus('Snapshot ready', 'info');
            } catch (err) {
                this.showStatus(`Snapshot error: ${err.message || err}`, 'warn');
            }
        }

        openStream(urlOverride = null) {
            if (this.paused) {
                return;
            }
            const url = urlOverride || this.streamUrl;
            if (!url) {
                return;
            }
            const wsUrl = resolveWsUrl(url);
            try {
                this.ws = new WebSocket(wsUrl);
            } catch (err) {
                this.showStatus(`WS unavailable: ${err.message || err}`, 'warn');
                this.scheduleReconnect();
                return;
            }
            this.ws.onopen = () => {
                this.backoffMs = 1500;
                this.showStatus('Streaming', 'info');
            };
            this.ws.onclose = () => {
                this.ws = null;
                if (!this.paused) {
                    this.showStatus(this.optimistic, 'warn');
                    this.scheduleReconnect();
                }
            };
            this.ws.onerror = () => {
                this.showStatus('Stream error', 'warn');
            };
            this.ws.onmessage = (event) => {
                try {
                    const payload = event.data ? JSON.parse(event.data) : {};
                    const data = this.parse(payload, 'stream');
                    this.acceptData(data, 'stream');
                } catch (err) {
                    this.showStatus(`Deserialisation error: ${err.message || err}`, 'error');
                }
            };
        }

        scheduleReconnect() {
            if (this.paused) {
                return;
            }
            const delay = Math.min(this.backoffMs, this.maxBackoff);
            setTimeout(() => {
                if (!this.paused) {
                    this.backoffMs = Math.min(this.backoffMs * 1.6, this.maxBackoff);
                    this.openStream();
                }
            }, delay);
        }

        acceptData(data, source = 'stream') {
            if (data === undefined || data === null) {
                return;
            }
            if (Array.isArray(data)) {
                data.forEach((entry) => this.records.push({ts: Date.now(), data: entry, source}));
            } else {
                this.records.push({ts: Date.now(), data, source});
            }
            if (this.records.length > this.maxRecords) {
                this.records.splice(0, this.records.length - this.maxRecords);
            }
            this.render();
            this.markActivity();
        }

        filteredRecords() {
            if (!this.windowed) {
                return this.records.slice();
            }
            const cutoff = Date.now() - this.windowSec * 1000;
            return this.records.filter((entry) => entry.ts >= cutoff);
        }

        render() {
            try {
                this.renderFn(this, this.filteredRecords());
            } catch (err) {
                console.error('Render failed for', this.key, err);
                this.showStatus(`Render failed: ${err.message || err}`, 'error');
            }
        }

        onPause() {
            if (this.ws) {
                try {
                    this.ws.close();
                } catch (err) {
                    console.debug('Failed to close websocket', err);
                }
            }
            this.ws = null;
        }

        onResume() {
            if (this.snapshotUrl) {
                this.fetchSnapshot();
            }
            if (this.streamUrl) {
                this.openStream();
            }
        }
    }

    class PollingPanel extends StreamPanel {
        constructor(key, element, options = {}) {
            super(key, element, options);
            this.intervalMs = (options.pollIntervalSec || 5) * 1000;
            this.timer = null;
        }

        init() {
            if (this.snapshotUrl) {
                this.fetchSnapshot();
            }
            if (this.streamUrl) {
                this.openStream();
            }
            if (this.intervalMs > 0) {
                this.timer = setInterval(() => {
                    if (!this.paused) {
                        this.fetchSnapshot();
                    }
                }, this.intervalMs);
            }
        }

        onPause() {
            super.onPause();
            if (this.timer) {
                clearInterval(this.timer);
            }
        }

        onResume() {
            super.onResume();
            if (this.intervalMs > 0) {
                this.timer = setInterval(() => {
                    if (!this.paused) {
                        this.fetchSnapshot();
                    }
                }, this.intervalMs);
            }
        }
    }

    const panelRegistry = new Map();
    const registerPanel = (key, controller) => {
        panelRegistry.set(key, controller);
        return controller;
    };


    const runHeaderEl = panelElements.get('run-header-safety-state');
    const runHeaderManifest = manifest.get('run-header-safety-state') || {};
    const healthIndicator = document.getElementById('health-indicator');
    const healthDot = healthIndicator.querySelector('.health-dot');
    const healthLabel = healthIndicator.querySelector('.label');

    const runHeaderPanel = registerPanel('run-header-safety-state', new StreamPanel('run-header-safety-state', runHeaderEl, {
        snapshotUrl: resolveManifestField(runHeaderManifest, 'snapshot') || '/api/run/state',
        streamUrl: resolveManifestField(runHeaderManifest, 'stream') || '/ws/run/state',
        parse: (payload) => {
            if (!payload || typeof payload !== 'object') {
                throw new Error('Invalid run state payload');
            }
            const required = ['mode', 'workflow', 'keypair_pubkey'];
            const missing = required.filter((field) => !(field in payload));
            if (missing.length) {
                throw new Error(`Missing fields: ${missing.join(', ')}`);
            }
            return payload;
        },
        render: (_panel, records) => {
            if (!records.length) {
                return;
            }
            const latest = records[records.length - 1].data || {};
            const workflow = String(latest.workflow || bootstrap.workflow || 'live').toUpperCase();
            const mode = String(latest.mode || bootstrap.mode || 'live').toUpperCase();
            document.getElementById('workflow-pill').textContent = workflow;
            document.getElementById('mode-pill').textContent = mode;
            if (bootstrap.canary) {
                document.getElementById('canary-pill').hidden = false;
            }
            document.getElementById('keypair-fingerprint').textContent = latest.keypair_pubkey || bootstrap.keypairFingerprint || '—';
            document.getElementById('keypair-path').textContent = bootstrap.keypairPath || '—';
            const budget = latest.budget_remaining ?? bootstrap.budgetRemaining;
            const risk = latest.risk_current ?? bootstrap.riskCurrent;
            document.getElementById('budget-remaining').textContent = formatCurrency(budget);
            document.getElementById('risk-current').textContent = formatNumber(risk, {digits: 4});
            const throttle = latest.rps_limits || bootstrap.rpsLimits || {};
            const throttleText = Object.entries(throttle).map(([name, value]) => `${name}:${value}`).join(' · ');
            document.getElementById('throttle-info').textContent = throttleText || '—';
            const backoff = latest.rpc_backoff || bootstrap.rpcBackoff;
            document.getElementById('rpc-backoff').textContent = backoff ? JSON.stringify(backoff) : '—';
            const eventUrl = (bootstrap.eventBus && bootstrap.eventBus.url) || 'ws://127.0.0.1:8779';
            const eventChannel = (bootstrap.eventBus && bootstrap.eventBus.channel) || 'solhunter-events-v3';
            document.getElementById('event-bus-info').textContent = `${eventUrl} · ${eventChannel}`;
            document.getElementById('redis-info').textContent = bootstrap.redisUrl || 'redis://localhost:6379/1';
            runHeaderPanel.showStatus('Streaming', 'info');
            probeHealth(latest);
        },
    }));

    runHeaderPanel.init();

    const copyEnvBtn = runHeaderEl.querySelector('[data-action="copy-env"]');
    if (copyEnvBtn) {
        copyEnvBtn.addEventListener('click', async () => {
            const envUrl = resolveManifestField(runHeaderManifest, 'env_snapshot') || bootstrap.envSnapshotUrl || '/api/run/env';
            try {
                const response = await fetch(resolveHttpUrl(envUrl), {cache: 'no-store'});
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const payload = await response.json();
                const masked = JSON.stringify(payload, (key, value) => {
                    if (typeof value === 'string' && value.length > 8) {
                        return `${value.slice(0, 4)}***${value.slice(-2)}`;
                    }
                    return value;
                }, 2);
                await navigator.clipboard.writeText(masked);
                runHeaderPanel.showStatus('Environment copied', 'info');
            } catch (err) {
                runHeaderPanel.showStatus(`Copy failed: ${err.message || err}`, 'warn');
            }
        });
    }

    const probeHealth = async () => {
        const healthUrl = resolveManifestField(runHeaderManifest, 'health') || bootstrap.healthUrl || '/api/health';
        try {
            const response = await fetch(resolveHttpUrl(healthUrl), {cache: 'no-store'});
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const payload = await response.json();
            const status = payload?.status || 'unknown';
            let level = 'ok';
            let text = 'Healthy';
            if (status !== 'ok') {
                level = 'warn';
                text = status;
            }
            if (Array.isArray(payload?.errors) && payload.errors.length) {
                level = 'danger';
                text = payload.errors[0].message || 'Degraded';
            }
            healthDot.classList.remove('ok', 'warn', 'danger');
            healthDot.classList.add(level === 'danger' ? 'danger' : level === 'warn' ? 'warn' : 'ok');
            healthLabel.textContent = text;
        } catch (err) {
            healthDot.classList.remove('ok');
            healthDot.classList.add('warn');
            healthLabel.textContent = `Health probe failed: ${err.message || err}`;
        }
    };


    const discoveryEl = panelElements.get('discovery-stream');
    const discoveryManifest = manifest.get('discovery-stream') || manifest.get('discovery-stream-mint-mempool') || {};
    const discoveryTimeline = document.getElementById('discovery-timeline');
    const discoveryMetaCache = new Map();
    let discoverySelectedMint = null;

    const discoveryPanel = registerPanel('discovery-stream', new StreamPanel('discovery-stream', discoveryEl, {
        snapshotUrl: resolveManifestField(discoveryManifest, 'snapshot') || '/api/discovery/recent?limit=200',
        streamUrl: resolveManifestField(discoveryManifest, 'stream') || '/ws/discovery',
        maxRecords: 800,
        parse: (payload, source) => {
            if (source === 'snapshot') {
                const items = Array.isArray(payload) ? payload : Array.isArray(payload?.recent) ? payload.recent : [];
                return items.map((entry) => normalizeDiscovery(entry));
            }
            return normalizeDiscovery(payload);
        },
        render: (_panel, records) => {
            const entries = [];
            records.forEach((record) => {
                if (Array.isArray(record.data)) {
                    record.data.forEach((entry) => entries.push(entry));
                } else {
                    entries.push(record.data);
                }
            });
            entries.sort((a, b) => b.ts - a.ts);
            discoveryTimeline.innerHTML = '';
            if (!entries.length) {
                const empty = document.createElement('div');
                empty.className = 'empty-state';
                empty.textContent = 'No discovery candidates yet.';
                discoveryTimeline.appendChild(empty);
                return;
            }
            entries.forEach((entry) => {
                const card = document.createElement('div');
                card.className = 'timeline-item';
                card.dataset.mint = entry.mint;
                if (entry.mint === discoverySelectedMint) {
                    card.classList.add('selected');
                }
                const meta = document.createElement('div');
                meta.className = 'meta';
                meta.innerHTML = `<span>${new Date(entry.ts).toLocaleTimeString()}</span><span class="badge">${entry.source}</span>`;
                const title = document.createElement('div');
                title.innerHTML = `<strong>${entry.symbol || entry.mint}</strong> · ${entry.quality}`;
                const routes = document.createElement('div');
                routes.className = 'meta';
                routes.innerHTML = `<span>${entry.mint}</span><span>${entry.routes.join(', ') || '—'}</span>`;
                card.appendChild(meta);
                card.appendChild(title);
                card.appendChild(routes);
                card.addEventListener('click', () => {
                    discoverySelectedMint = entry.mint;
                    selectedMintStore.set(entry.mint);
                    highlightDiscovery(entry.mint);
                });
                discoveryTimeline.appendChild(card);
                if (!discoveryMetaCache.has(entry.mint)) {
                    fetchTokenMeta(entry.mint).catch(() => {});
                }
            });
        },
    }));

    discoveryPanel.init();

    const normalizeDiscovery = (payload) => {
        if (!payload || typeof payload !== 'object') {
            throw new Error('Discovery payload malformed');
        }
        const ts = Number(payload.ts || payload.timestamp || Date.now());
        const mint = String(payload.mint || payload.address || '');
        if (!mint) {
            throw new Error('Discovery missing mint');
        }
        const source = String(payload.source || payload.origin || 'mint');
        const quality = Number(payload.quality || payload.score || 0).toFixed(2);
        const routes = [];
        const rawRoutes = payload.routes || payload.dex || payload.venues;
        if (Array.isArray(rawRoutes)) {
            rawRoutes.forEach((route) => {
                if (route) {
                    routes.push(String(route));
                }
            });
        }
        return {
            ts,
            mint,
            source,
            quality,
            routes,
            symbol: payload.symbol || payload.name || null,
        };
    };

    const fetchTokenMeta = async (mint) => {
        const metaUrl = resolveManifestField(discoveryManifest, 'meta') || '/api/token/meta/:mint';
        const url = resolveHttpUrl(metaUrl.replace(':mint', encodeURIComponent(mint)));
        const response = await fetch(url, {cache: 'no-store'});
        if (response.ok) {
            const payload = await response.json();
            discoveryMetaCache.set(mint, payload);
            return payload;
        }
        throw new Error(`HTTP ${response.status}`);
    };

    const highlightDiscovery = (mint) => {
        discoveryTimeline.querySelectorAll('.timeline-item').forEach((item) => {
            if (item.dataset.mint === mint) {
                item.classList.add('selected');
            } else {
                item.classList.remove('selected');
            }
        });
    };


    class TokenPanel extends PanelController {
        constructor(element) {
            super('token-deep-view', element);
            this.currentMint = null;
            this.priceHistory = [];
            this.priceWs = null;
            this.depthWs = null;
            this.detailsEl = document.getElementById('token-details');
            this.depthEl = document.getElementById('depth-details');
            this.warningEl = document.getElementById('token-warning');
            this.sparklineEl = document.getElementById('token-sparkline');
        }

        init() {
            this.showStatus('Pick a discovery candidate.', 'warn');
        }

        async load(mint) {
            this.currentMint = mint;
            this.priceHistory = [];
            depthStore.set(null);
            this.detailsEl.innerHTML = '';
            this.depthEl.innerHTML = '';
            this.sparklineEl.innerHTML = '';
            if (!mint) {
                this.showStatus('Pick a discovery candidate.', 'warn');
                return;
            }
            this.showStatus('Loading token snapshot…', 'info');
            try {
                await Promise.all([
                    this.fetchMeta(mint),
                    this.fetchPrice(mint),
                ]);
                this.showStatus('Streaming', 'info');
            } catch (err) {
                this.showStatus(`Snapshot failed: ${err.message || err}`, 'warn');
            }
            this.openPriceStream(mint);
            this.openDepthStream(mint);
        }

        async fetchMeta(mint) {
            const url = resolveHttpUrl(`/api/token/${encodeURIComponent(mint)}`.replace('//api', '/api'));
            const response = await fetch(url, {cache: 'no-store'});
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const payload = await response.json();
            this.renderMeta(payload);
        }

        async fetchPrice(mint) {
            const url = resolveHttpUrl(`/api/price/${encodeURIComponent(mint)}`.replace('//api', '/api'));
            const response = await fetch(url, {cache: 'no-store'});
            if (response.ok) {
                this.ingestPrice(await response.json());
            }
        }

        renderMeta(meta) {
            this.detailsEl.innerHTML = '';
            const rows = [
                ['Mint', meta.mint || this.currentMint],
                ['Symbol', meta.symbol || meta.ticker || '—'],
                ['Name', meta.name || '—'],
                ['Decimals', meta.decimals ?? '—'],
                ['Supply', meta.supply ? meta.supply.toLocaleString() : '—'],
                ['Holders', meta.holders || meta.holder_count || '—'],
            ];
            rows.forEach(([label, value]) => {
                const card = document.createElement('div');
                card.className = 'detail-card';
                card.innerHTML = `<div class="label">${label}</div><div class="value">${value}</div>`;
                this.detailsEl.appendChild(card);
            });
            if (meta.invalid) {
                this.warningEl.hidden = false;
                this.warningEl.textContent = 'Invalid mint reported upstream. Monitoring only.';
            } else {
                this.warningEl.hidden = true;
            }
        }

        ingestPrice(payload) {
            if (!payload || typeof payload !== 'object') {
                return;
            }
            const price = Number(payload.price || payload.value || payload.px);
            if (Number.isFinite(price)) {
                this.priceHistory.push({ts: Date.now(), price});
                if (this.priceHistory.length > 256) {
                    this.priceHistory.shift();
                }
            }
            const details = [
                ['Price', formatCurrency(price)],
                ['24h Return', formatPercent(payload.returns_24h || payload.return24h || 0)],
                ['Liquidity', formatCurrency(payload.liquidity || payload.liq_usd || 0)],
                ['Volume 24h', formatCurrency(payload.volume_24h || payload.vol_usd || 0)],
            ];
            details.forEach(([label, value], index) => {
                let card = this.detailsEl.children[index];
                if (!card) {
                    card = document.createElement('div');
                    card.className = 'detail-card';
                    this.detailsEl.appendChild(card);
                }
                card.innerHTML = `<div class="label">${label}</div><div class="value">${value}</div>`;
            });
            this.renderSparkline();
        }

        renderSparkline() {
            const points = this.priceHistory.slice(-80);
            if (!points.length) {
                this.sparklineEl.innerHTML = '';
                return;
            }
            const prices = points.map((entry) => entry.price);
            const min = Math.min(...prices);
            const max = Math.max(...prices);
            const range = max - min || 1;
            const width = this.sparklineEl.clientWidth || 240;
            const height = this.sparklineEl.clientHeight || 56;
            const step = width / Math.max(points.length - 1, 1);
            const path = points.map((entry, idx) => {
                const x = idx * step;
                const y = height - ((entry.price - min) / range) * height;
                return `${idx ? 'L' : 'M'}${x.toFixed(2)},${y.toFixed(2)}`;
            }).join(' ');
            this.sparklineEl.innerHTML = `<path d="${path}" fill="none" stroke="url(#sparklineGradient)" stroke-width="2" />`;
            if (!this.sparklineEl.querySelector('defs')) {
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                defs.innerHTML = '<linearGradient id="sparklineGradient" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#4f9cff" /><stop offset="100%" stop-color="#8b5cf6" /></linearGradient>';
                this.sparklineEl.prepend(defs);
            }
        }

        openPriceStream(mint) {
            if (this.priceWs) {
                this.priceWs.close();
            }
            const url = resolveWsUrl(`/ws/price/${encodeURIComponent(mint)}`.replace('//ws', '/ws'));
            try {
                this.priceWs = new WebSocket(url);
            } catch (err) {
                console.warn('Price websocket unavailable', err);
                return;
            }
            this.priceWs.onmessage = (event) => {
                try {
                    const payload = JSON.parse(event.data || '{}');
                    this.ingestPrice(payload);
                } catch (err) {
                    console.warn('Price stream parse failed', err);
                }
            };
            this.priceWs.onclose = () => {
                this.priceWs = null;
            };
        }

        openDepthStream(mint) {
            if (this.depthWs) {
                this.depthWs.close();
            }
            const url = resolveWsUrl(`/ws/depth/${encodeURIComponent(mint)}`.replace('//ws', '/ws'));
            try {
                this.depthWs = new WebSocket(url);
            } catch (err) {
                console.warn('Depth websocket unavailable', err);
                return;
            }
            this.depthWs.onmessage = (event) => {
                try {
                    const payload = JSON.parse(event.data || '{}');
                    depthStore.set(payload);
                    this.renderDepth(payload);
                } catch (err) {
                    console.warn('Depth stream parse failed', err);
                }
            };
            this.depthWs.onclose = () => {
                this.depthWs = null;
            };
        }

        renderDepth(depth) {
            this.depthEl.innerHTML = '';
            if (!depth || typeof depth !== 'object') {
                return;
            }
            const rows = [
                ['Bids', depth.bids ? depth.bids.length : 0],
                ['Asks', depth.asks ? depth.asks.length : 0],
                ['Best bid', depth.best_bid ? formatCurrency(depth.best_bid) : '—'],
                ['Best ask', depth.best_ask ? formatCurrency(depth.best_ask) : '—'],
                ['Spread bps', depth.spread_bps != null ? Number(depth.spread_bps).toFixed(2) : '—'],
            ];
            rows.forEach(([label, value]) => {
                const card = document.createElement('div');
                card.className = 'detail-card';
                card.innerHTML = `<div class="label">${label}</div><div class="value">${value}</div>`;
                this.depthEl.appendChild(card);
            });
        }

        onPause() {
            if (this.priceWs) {
                this.priceWs.close();
                this.priceWs = null;
            }
            if (this.depthWs) {
                this.depthWs.close();
                this.depthWs = null;
            }
        }

        onResume() {
            if (this.currentMint) {
                this.openPriceStream(this.currentMint);
                this.openDepthStream(this.currentMint);
            }
        }
    }

    const tokenPanel = registerPanel('token-deep-view', new TokenPanel(panelElements.get('token-deep-view')));
    tokenPanel.init();
    selectedMintStore.subscribe((mint) => {
        tokenPanel.load(mint).catch((err) => tokenPanel.showStatus(err.message || err, 'warn'));
    });
    depthStore.subscribe((depth) => {
        if (depth) {
            tokenPanel.renderDepth(depth);
        }
    });


    const agentEl = panelElements.get('agent-swarm-timeline');
    const agentManifest = manifest.get('agent-swarm-timeline') || {};
    const agentTimeline = document.getElementById('agent-timeline');

    class AgentPanel extends StreamPanel {
        constructor(element) {
            super('agent-swarm-timeline', element, {
                snapshotUrl: null,
                streamUrl: resolveManifestField(agentManifest, 'stream') || '/ws/agents/events',
                parse: (payload) => normalizeAgentEvent(payload),
                render: (_panel, records) => renderAgentTimeline(records),
            });
            this.currentMint = null;
        }

        setMint(mint) {
            this.currentMint = mint;
            this.records = [];
            agentTimeline.innerHTML = '';
            if (!mint) {
                this.showStatus('Pick a discovery candidate.', 'warn');
                return;
            }
            this.showStatus('Loading agent history…', 'info');
            this.fetchSnapshot(mint).then(() => {
                this.showStatus('Streaming', 'info');
            }).catch((err) => {
                this.showStatus(`Backfill failed: ${err.message || err}`, 'warn');
            });
            this.openStream(`${resolveManifestField(agentManifest, 'stream') || '/ws/agents/events'}?mint=${encodeURIComponent(mint)}`);
        }

        async fetchSnapshot(mint) {
            const template = resolveManifestField(agentManifest, 'snapshot') || '/api/agents/events?mint=:mint&since=:ts';
            const since = Math.floor(Date.now() / 1000) - 3600;
            const url = resolveHttpUrl(template.replace(':mint', encodeURIComponent(mint)).replace(':ts', String(since)));
            const response = await fetch(url, {cache: 'no-store'});
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const payload = await response.json();
            const events = Array.isArray(payload) ? payload : Array.isArray(payload?.events) ? payload.events : [];
            events.forEach((event) => this.acceptData(normalizeAgentEvent(event), 'snapshot'));
        }

        acceptData(data, source) {
            if (!data) {
                return;
            }
            super.acceptData(data, source);
        }

        onPause() {
            super.onPause();
        }

        onResume() {
            if (this.currentMint) {
                this.setMint(this.currentMint);
            }
        }
    }

    const normalizeAgentEvent = (payload) => {
        if (!payload || typeof payload !== 'object') {
            throw new Error('Agent payload malformed');
        }
        return {
            ts: Number(payload.ts || payload.timestamp || Date.now()),
            time: new Date(payload.ts || payload.timestamp || Date.now()).toLocaleTimeString(),
            agent: payload.agent_id || payload.agent || 'unknown',
            intent: (payload.intent || 'hold').toUpperCase(),
            confidence: Number(payload.confidence || 0).toFixed(1),
            features: Object.entries(payload.features || {}).map(([key, value]) => `${key}:${value}`).join(' · '),
            error: payload.error || payload.invalid_mint || null,
        };
    };

    const renderAgentTimeline = (records) => {
        agentTimeline.innerHTML = '';
        const entries = records.slice(-120).reverse();
        if (!entries.length) {
            const empty = document.createElement('div');
            empty.className = 'empty-state';
            empty.textContent = 'Awaiting agent emissions…';
            agentTimeline.appendChild(empty);
            return;
        }
        entries.forEach((entry) => {
            const data = entry.data || entry;
            const card = document.createElement('div');
            card.className = 'timeline-item';
            card.innerHTML = `
                <div class="meta"><span>${data.time}</span><span class="badge">${data.intent}</span></div>
                <div><strong>${data.agent}</strong> · ${data.confidence}%</div>
                <div class="meta">${data.features}</div>
                ${data.error ? `<div class="error-banner">${data.error}</div>` : ''}
            `;
            agentTimeline.appendChild(card);
        });
    };

    const agentPanel = registerPanel('agent-swarm-timeline', new AgentPanel(agentEl));
    agentPanel.init();
    selectedMintStore.subscribe((mint) => agentPanel.setMint(mint));


    const planEl = panelElements.get('trade-planner-routing');
    const planManifest = manifest.get('trade-planner-routing') || {};
    const planDetails = document.getElementById('plan-details');
    const dryRunCard = document.getElementById('dry-run-card');
    const dryRunResult = document.getElementById('dry-run-result');
    const dryRunSlippage = document.getElementById('dry-run-slippage');

    class PlanPanel extends StreamPanel {
        constructor(element) {
            super('trade-planner-routing', element, {
                snapshotUrl: null,
                streamUrl: resolveManifestField(planManifest, 'stream') || '/ws/execution/plan',
                parse: (payload) => payload,
                render: () => this.renderPlan(),
            });
            this.currentMint = null;
            this.plan = null;
        }

        setMint(mint) {
            this.currentMint = mint;
            this.plan = null;
            planDetails.innerHTML = '';
            dryRunCard.hidden = true;
            if (!mint) {
                this.showStatus('Pick a discovery candidate.', 'warn');
                return;
            }
            this.showStatus('Loading execution plan…', 'info');
            this.fetchSnapshot(mint).catch((err) => this.showStatus(`Snapshot failed: ${err.message || err}`, 'warn'));
        }

        async fetchSnapshot(mint) {
            const template = resolveManifestField(planManifest, 'snapshot') || '/api/execution/plan?mint=:mint';
            const url = resolveHttpUrl(template.replace(':mint', encodeURIComponent(mint)));
            const response = await fetch(url, {cache: 'no-store'});
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const payload = await response.json();
            this.plan = payload;
            planStore.set({mint, plan: payload});
            this.renderPlan();
            this.showStatus('Streaming', 'info');
        }

        acceptData(data, source) {
            if (data && data.mint) {
                this.plan = data;
                planStore.set({mint: data.mint, plan: data});
                this.renderPlan();
                this.markActivity();
            }
        }

        renderPlan() {
            planDetails.innerHTML = '';
            dryRunCard.hidden = true;
            if (!this.plan) {
                return;
            }
            const rows = [
                ['Mint', this.plan.mint || this.currentMint || '—'],
                ['Intent', (this.plan.intent || 'hold').toUpperCase()],
                ['Router', this.plan.router || this.plan.route || '—'],
                ['Expected slippage', `${Number(this.plan.expected_slippage_bps || this.plan.slippage_bps || 0).toFixed(2)} bps`],
                ['Size', formatNumber(this.plan.size || this.plan.notional, {digits: 4})],
                ['Bundle', this.plan.bundle_preference || (this.plan.bundle ? 'Jito' : 'off')],
            ];
            rows.forEach(([label, value]) => {
                const card = document.createElement('div');
                card.className = 'detail-card';
                card.innerHTML = `<div class="label">${label}</div><div class="value">${value}</div>`;
                planDetails.appendChild(card);
            });
            this.runDryRun();
        }

        runDryRun() {
            const depth = depthStore.get();
            if (!depth || !this.plan) {
                dryRunCard.hidden = true;
                return;
            }
            const size = Number(this.plan.size || this.plan.notional || 0);
            const bestAsk = Number(depth.best_ask || depth.ask || 0);
            const bestBid = Number(depth.best_bid || depth.bid || 0);
            if (!Number.isFinite(size) || size <= 0 || !Number.isFinite(bestAsk) || !Number.isFinite(bestBid) || bestAsk <= 0 || bestBid <= 0) {
                dryRunCard.hidden = true;
                return;
            }
            const mid = (bestAsk + bestBid) / 2;
            const impact = (size / Math.max(depth.asks?.[0]?.size || size, 1)) * Math.abs(bestAsk - bestBid);
            dryRunResult.textContent = formatCurrency(mid + impact / 2);
            dryRunSlippage.textContent = `${((impact / mid) * 10_000).toFixed(2)} bps`;
            dryRunCard.hidden = false;
        }

        onResume() {
            if (this.currentMint) {
                this.fetchSnapshot(this.currentMint).catch((err) => this.showStatus(err.message || err, 'warn'));
            }
            super.onResume();
        }
    }

    const planPanel = registerPanel('trade-planner-routing', new PlanPanel(planEl));
    planPanel.init();
    selectedMintStore.subscribe((mint) => planPanel.setMint(mint));
    depthStore.subscribe(() => planPanel.runDryRun());


    const fillsEl = panelElements.get('orders-fills-slippage');
    const fillsManifest = manifest.get('orders-fills-slippage') || {};
    const fillsTable = document.getElementById('fills-table');
    const fillsTbody = fillsTable.querySelector('tbody');
    const fillsSummary = document.getElementById('fills-summary');

    const fillsPanel = registerPanel('orders-fills-slippage', new StreamPanel('orders-fills-slippage', fillsEl, {
        snapshotUrl: resolveManifestField(fillsManifest, 'snapshot') || '/api/execution/fills?limit=500',
        streamUrl: resolveManifestField(fillsManifest, 'stream') || '/ws/execution/fills',
        maxRecords: 600,
        parse: (payload, source) => {
            if (source === 'snapshot') {
                const entries = Array.isArray(payload) ? payload : Array.isArray(payload?.fills) ? payload.fills : [];
                return entries.map(normalizeFill);
            }
            return normalizeFill(payload);
        },
        render: (_panel, records) => {
            const rows = [];
            records.forEach((record) => {
                if (Array.isArray(record.data)) {
                    record.data.forEach((entry) => rows.push(entry));
                } else {
                    rows.push(record.data);
                }
            });
            rows.sort((a, b) => b.ts - a.ts);
            renderFillsTable(rows);
            renderFillsSummary(rows);
        },
    }));

    const normalizeFill = (payload) => {
        if (!payload || typeof payload !== 'object') {
            throw new Error('Fill payload malformed');
        }
        return {
            ts: Number(payload.ts || payload.timestamp || Date.now()),
            mint: payload.mint || payload.token || 'unknown',
            side: (payload.side || '').toUpperCase(),
            qty: Number(payload.quantity || payload.qty || 0),
            route: payload.route || payload.router || '—',
            quoted: Number(payload.quoted_price || payload.quote || 0),
            realized: Number(payload.realized_price || payload.price || 0),
            slippage: Number(payload.slippage_bps || payload.slippage || 0),
            fees: Number(payload.fees || 0),
            status: payload.status || payload.state || 'pending',
            txid: payload.txid || payload.signature || null,
        };
    };

    const renderFillsTable = (rows) => {
        fillsTbody.innerHTML = '';
        rows.forEach((row) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td title="${new Date(row.ts).toISOString()}">${new Date(row.ts).toLocaleTimeString()}</td>
                <td>${row.mint}</td>
                <td>${row.side}</td>
                <td>${row.qty.toFixed(4)}</td>
                <td>${row.route}</td>
                <td>${formatCurrency(row.quoted)}</td>
                <td>${formatCurrency(row.realized)}</td>
                <td>${row.slippage.toFixed(2)}</td>
                <td>${formatCurrency(row.fees)}</td>
                <td>${row.status}</td>
            `;
            if (row.txid) {
                tr.classList.add('link-copy');
                tr.addEventListener('click', () => {
                    navigator.clipboard.writeText(row.txid).catch(() => {});
                    window.open(`https://solscan.io/tx/${row.txid}`, '_blank');
                });
            }
            fillsTbody.appendChild(tr);
        });
        makeSortable(fillsTable, 'fills-table');
    };

    const renderFillsSummary = (rows) => {
        fillsSummary.innerHTML = '';
        const perMint = new Map();
        rows.forEach((row) => {
            const entry = perMint.get(row.mint) || {slippage: 0, fees: 0, count: 0};
            entry.slippage += row.slippage;
            entry.fees += row.fees;
            entry.count += 1;
            perMint.set(row.mint, entry);
        });
        perMint.forEach((entry, mint) => {
            const card = document.createElement('div');
            card.className = 'detail-card';
            card.innerHTML = `<div class="label">${mint}</div><div class="value">Slippage ${(entry.slippage / Math.max(entry.count, 1)).toFixed(2)} bps · Fees ${formatCurrency(entry.fees)}</div>`;
            fillsSummary.appendChild(card);
        });
    };

    fillsPanel.init();


    const positionsEl = panelElements.get('positions-portfolio');
    const positionsManifest = manifest.get('positions-portfolio') || {};
    const positionsTable = document.getElementById('positions-table');
    const positionsBody = positionsTable.querySelector('tbody');
    const cashSummary = document.getElementById('cash-summary');

    const positionsPanel = registerPanel('positions-portfolio', new PollingPanel('positions-portfolio', positionsEl, {
        snapshotUrl: resolveManifestField(positionsManifest, 'snapshot') || '/api/portfolio/positions',
        streamUrl: resolveManifestField(positionsManifest, 'stream') || '/ws/portfolio',
        pollIntervalSec: Number(resolveManifestField(positionsManifest, 'poll_interval_s') || 5),
        parse: (payload, source) => {
            if (source === 'snapshot') {
                const rows = Array.isArray(payload) ? payload : Array.isArray(payload?.positions) ? payload.positions : [];
                return rows.map(normalizePosition);
            }
            return normalizePosition(payload);
        },
        render: (_panel, records) => {
            const rows = [];
            records.forEach((record) => {
                if (Array.isArray(record.data)) {
                    record.data.forEach((entry) => rows.push(entry));
                } else {
                    rows.push(record.data);
                }
            });
            rows.sort((a, b) => a.mint.localeCompare(b.mint));
            renderPositions(rows);
        },
    }));

    const normalizePosition = (payload) => {
        if (!payload || typeof payload !== 'object') {
            throw new Error('Position payload malformed');
        }
        return {
            mint: payload.mint || 'unknown',
            qty: Number(payload.quantity || payload.qty || 0),
            avg_cost: Number(payload.avg_cost || payload.cost || 0),
            mark: Number(payload.mark_price || payload.mark || 0),
            ue_pnl: Number(payload.unrealized_pnl || payload.ue || 0),
            realized_pnl: Number(payload.realized_pnl || payload.realized || 0),
            risk_weight: Number(payload.risk_weight || payload.risk || 0),
            canary: Boolean(payload.canary || payload.read_only),
        };
    };

    const renderPositions = (rows) => {
        positionsBody.innerHTML = '';
        let totalUnrealized = 0;
        let totalRealized = 0;
        rows.forEach((row) => {
            totalUnrealized += row.ue_pnl;
            totalRealized += row.realized_pnl;
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${row.mint}</td>
                <td>${row.qty.toFixed(4)}</td>
                <td>${formatCurrency(row.avg_cost)}</td>
                <td>${formatCurrency(row.mark)}</td>
                <td>${formatCurrency(row.ue_pnl)}</td>
                <td>${formatCurrency(row.realized_pnl)}</td>
                <td>${row.risk_weight.toFixed(2)}</td>
                <td><button type="button" data-action="close" data-mint="${row.mint}" data-qty="${row.qty.toFixed(4)}">Close</button></td>
            `;
            const closeBtn = tr.querySelector('[data-action="close"]');
            if (closeBtn) {
                closeBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    attemptClose(row);
                });
                if (bootstrap.canary || row.canary || (planStore.get()?.plan?.intent || '').toLowerCase() === 'hold') {
                    closeBtn.disabled = true;
                }
            }
            positionsBody.appendChild(tr);
        });
        makeSortable(positionsTable, 'positions-table');
        cashSummary.innerHTML = '';
        const card = document.createElement('div');
        card.className = 'detail-card';
        card.innerHTML = `<div class="label">Portfolio summary</div><div class="value">Unrealized ${formatCurrency(totalUnrealized)} · Realized ${formatCurrency(totalRealized)}</div>`;
        cashSummary.appendChild(card);
    };

    const attemptClose = async (row) => {
        const endpoint = resolveManifestField(positionsManifest, 'close_endpoint') || '/api/execution/close?mint=:mint&qty=:qty';
        const url = resolveHttpUrl(endpoint.replace(':mint', encodeURIComponent(row.mint)).replace(':qty', encodeURIComponent(row.qty)));
        try {
            const response = await fetch(url, {method: 'POST', headers: {'Content-Type': 'application/json'}});
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            positionsPanel.showStatus(`Close requested for ${row.mint}`, 'info');
        } catch (err) {
            positionsPanel.showStatus(`Close failed: ${err.message || err}`, 'warn');
        }
    };

    positionsPanel.init();


    const pnlEl = panelElements.get('pnl-risk-overview');
    const pnlManifest = manifest.get('pnl-risk-overview') || {};
    const pnlCards = document.getElementById('pnl-cards');
    const riskBanner = document.getElementById('risk-banner');

    const pnlPanel = registerPanel('pnl-risk-overview', new StreamPanel('pnl-risk-overview', pnlEl, {
        snapshotUrl: resolveManifestField(pnlManifest, 'snapshot') || '/api/portfolio/pnl?window=1h',
        streamUrl: resolveManifestField(pnlManifest, 'stream') || '/ws/risk',
        parse: (payload, source) => payload,
        render: () => renderPnl(),
    }));

    const fetchAdditionalPnl = async () => {
        const altUrl = resolveManifestField(pnlManifest, 'snapshot_alt') || '/api/portfolio/pnl?window=24h';
        try {
            const response = await fetch(resolveHttpUrl(altUrl), {cache: 'no-store'});
            if (response.ok) {
                pnlPanel.acceptData({window: '24h', payload: await response.json()}, 'snapshot');
            }
        } catch (err) {
            console.debug('PnL alt fetch failed', err);
        }
    };

    const renderPnl = () => {
        pnlCards.innerHTML = '';
        const records = pnlPanel.filteredRecords();
        const latestRisk = records.find((record) => record.source === 'stream' && record.data && record.data.risk);
        const pnlEntries = records
            .filter((record) => record.data && (record.data.window || record.data.pnl))
            .slice(-4);
        pnlEntries.forEach((entry) => {
            const data = entry.data;
            if (data.window && data.payload) {
                const card = document.createElement('div');
                card.className = 'detail-card';
                card.innerHTML = `<div class="label">PnL ${data.window}</div><div class="value">${formatCurrency(data.payload.pnl || data.payload.total || 0)}</div>`;
                pnlCards.appendChild(card);
            } else if (data.pnl) {
                const card = document.createElement('div');
                card.className = 'detail-card';
                card.innerHTML = `<div class="label">PnL</div><div class="value">${formatCurrency(data.pnl)}</div>`;
                pnlCards.appendChild(card);
            }
        });
        if (latestRisk && latestRisk.data) {
            const risk = latestRisk.data.risk || latestRisk.data;
            const card = document.createElement('div');
            card.className = 'detail-card';
            card.innerHTML = `<div class="label">VaR proxy</div><div class="value">${formatCurrency(risk.var || risk.var_proxy || 0)} · Utilization ${(Number(risk.utilization || risk.util || 0) * 100).toFixed(2)}%</div>`;
            pnlCards.appendChild(card);
            if (risk.hard_stop || risk.stop_triggered) {
                riskBanner.hidden = false;
                riskBanner.textContent = `Hard stop active: ${risk.hard_stop || risk.stop_triggered}`;
            } else if (risk.tolerance_changed || risk.multiplier_changed) {
                riskBanner.hidden = false;
                riskBanner.textContent = 'Risk parameters updated mid-run';
            } else {
                riskBanner.hidden = true;
            }
        }
    };

    pnlPanel.init();
    fetchAdditionalPnl();


    const runtimeEl = panelElements.get('runtime-health-rate-limits');
    const runtimeManifest = manifest.get('runtime-health-rate-limits') || {};
    const runtimeCards = document.getElementById('runtime-health-cards');
    const rateLimitBanner = document.getElementById('rate-limit-banner');

    const runtimePanel = registerPanel('runtime-health-rate-limits', new StreamPanel('runtime-health-rate-limits', runtimeEl, {
        snapshotUrl: resolveManifestField(runtimeManifest, 'snapshot') || '/api/health',
        streamUrl: resolveManifestField(runtimeManifest, 'stream') || '/ws/metrics',
        parse: (payload, source) => payload,
        render: () => renderRuntime(),
    }));

    const providerStatusUrl = resolveManifestField(runtimeManifest, 'providers_snapshot') || '/api/providers/status';

    const renderRuntime = async () => {
        runtimeCards.innerHTML = '';
        const records = runtimePanel.filteredRecords();
        const latest = records[records.length - 1]?.data || {};
        const cards = [];
        if (latest.helius) {
            cards.push(['Helius 2xx', latest.helius.success || 0]);
            cards.push(['Helius 429', latest.helius.throttle || 0]);
        }
        if (latest.das) {
            cards.push(['DAS RPS', latest.das.rps || latest.das.current || 0]);
        }
        if (latest.redis_latency) {
            cards.push(['Redis latency', `${latest.redis_latency.toFixed ? latest.redis_latency.toFixed(1) : latest.redis_latency} ms`]);
        }
        cards.forEach(([label, value]) => {
            const card = document.createElement('div');
            card.className = 'detail-card';
            card.innerHTML = `<div class="label">${label}</div><div class="value">${value}</div>`;
            runtimeCards.appendChild(card);
        });
        try {
            const response = await fetch(resolveHttpUrl(providerStatusUrl), {cache: 'no-store'});
            if (response.ok) {
                const payload = await response.json();
                const has429 = Object.values(payload || {}).some((item) => item && Number(item.status_429 || item.throttle || 0) > 0);
                if (has429) {
                    rateLimitBanner.hidden = false;
                    rateLimitBanner.textContent = '429 throttling detected on providers';
                } else {
                    rateLimitBanner.hidden = true;
                }
            }
        } catch (err) {
            console.debug('Provider status fetch failed', err);
        }
    };

    runtimePanel.init();


    const logsEl = panelElements.get('structured-logs-live');
    const logsManifest = manifest.get('structured-logs-live') || {};
    const logsList = document.getElementById('logs-list');

    const logsPanel = registerPanel('structured-logs-live', new StreamPanel('structured-logs-live', logsEl, {
        snapshotUrl: resolveManifestField(logsManifest, 'snapshot') || '/api/logs/tail?lines=500',
        streamUrl: resolveManifestField(logsManifest, 'stream') || '/ws/logs?level=INFO|WARN|ERROR',
        maxRecords: 500,
        parse: (payload, source) => {
            if (source === 'snapshot') {
                const lines = Array.isArray(payload) ? payload : Array.isArray(payload?.logs) ? payload.logs : [];
                return lines.map(normalizeLog);
            }
            return normalizeLog(payload);
        },
        render: (_panel, records) => {
            logsList.innerHTML = '';
            const entries = records.slice(-300).reverse();
            if (!entries.length) {
                const empty = document.createElement('div');
                empty.className = 'empty-state';
                empty.textContent = 'No logs yet.';
                logsList.appendChild(empty);
                return;
            }
            entries.forEach((entry) => {
                const data = entry.data || entry;
                const div = document.createElement('div');
                div.className = 'log-entry';
                if (data.level) {
                    div.dataset.level = data.level;
                }
                div.innerHTML = `<strong>${data.level}</strong> · ${data.time} · ${data.message}`;
                if (data.mint) {
                    div.addEventListener('click', () => selectedMintStore.set(data.mint));
                }
                logsList.appendChild(div);
            });
        },
    }));

    const normalizeLog = (payload) => {
        if (!payload || typeof payload !== 'object') {
            throw new Error('Log payload malformed');
        }
        return {
            level: (payload.level || 'INFO').toUpperCase(),
            time: new Date(payload.ts || payload.timestamp || Date.now()).toLocaleTimeString(),
            message: payload.message || payload.msg || JSON.stringify(payload),
            mint: payload.mint || null,
        };
    };

    logsPanel.init();


    const makeSortable = (table, storageKey) => {
        const headers = Array.from(table.querySelectorAll('th[data-sort-key]'));
        if (!headers.length) {
            return;
        }
        const key = `solhunter-sort-${storageKey}`;
        let sortState = null;
        try {
            sortState = JSON.parse(localStorage.getItem(key));
        } catch (err) {
            sortState = null;
        }
        if (sortState && sortState.column != null) {
            applySort(sortState.column, sortState.direction);
        }
        headers.forEach((header, index) => {
            header.addEventListener('click', () => {
                const nextDirection = sortState && sortState.column === index && sortState.direction === 'asc' ? 'desc' : 'asc';
                applySort(index, nextDirection);
                localStorage.setItem(key, JSON.stringify({column: index, direction: nextDirection}));
            });
        });

        function applySort(columnIndex, direction) {
            headers.forEach((header, idx) => {
                header.classList.toggle('sort-asc', idx === columnIndex && direction === 'asc');
                header.classList.toggle('sort-desc', idx === columnIndex && direction === 'desc');
            });
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            rows.sort((a, b) => {
                const aText = a.children[columnIndex]?.textContent || '';
                const bText = b.children[columnIndex]?.textContent || '';
                const aValue = Number(aText.replace(/[^0-9.-]+/g, ''));
                const bValue = Number(bText.replace(/[^0-9.-]+/g, ''));
                if (!Number.isNaN(aValue) && !Number.isNaN(bValue)) {
                    return direction === 'asc' ? aValue - bValue : bValue - aValue;
                }
                return direction === 'asc' ? aText.localeCompare(bText) : bText.localeCompare(aText);
            });
            rows.forEach((row) => tbody.appendChild(row));
            sortState = {column: columnIndex, direction};
        }
    };


    positionsPanel.simulatePnL = () => {
        const rows = positionsPanel.filteredRecords().map((record) => record.data).filter(Boolean);
        if (!rows.length) {
            return false;
        }
        const sample = rows[0];
        const fill = {price: sample.mark || 0, qty: sample.qty || 0};
        return Number.isFinite(fill.price) && Number.isFinite(fill.qty);
    };

    runtimePanel.hasProviderStats = () => {
        const records = runtimePanel.filteredRecords();
        if (!records.length) {
            return false;
        }
        const latest = records[records.length - 1].data || {};
        return Boolean(latest.helius || latest.das || latest.redis_latency);
    };


    const selfCheckBtn = runHeaderEl.querySelector('[data-action="self-check"]');
    const selfCheckDuration = Number(bootstrap.selfCheckDurationMs || 30_000);

    const runSelfCheck = async () => {
        runHeaderPanel.showStatus('Self-check running…', 'info');
        const activityPromises = [];
        panelRegistry.forEach((panel) => {
            if (panel && typeof panel.waitForActivity === 'function') {
                activityPromises.push(panel.waitForActivity(selfCheckDuration));
            }
        });
        const firstDiscovery = discoveryTimeline.querySelector('.timeline-item');
        if (firstDiscovery && firstDiscovery.dataset.mint) {
            selectedMintStore.set(firstDiscovery.dataset.mint);
        }
        try {
            await Promise.all(activityPromises);
            await new Promise((resolve) => setTimeout(resolve, Math.min(selfCheckDuration, 1500)));
            const pnlOk = positionsPanel.simulatePnL();
            const runtimeOk = runtimePanel.hasProviderStats();
            if (!pnlOk) {
                throw new Error('Portfolio feed unable to simulate PnL');
            }
            if (!runtimeOk) {
                throw new Error('Provider metrics missing 2xx/429 data');
            }
            console.log('UI ready: 10/10 panels wired, no dead panels');
            runHeaderPanel.showStatus('Self-check complete', 'info');
        } catch (err) {
            runHeaderPanel.showStatus(`Self-check failed: ${err.message || err}`, 'warn');
        }
    };

    if (selfCheckBtn) {
        selfCheckBtn.addEventListener('click', () => runSelfCheck());
    }

    setTimeout(() => {
        runSelfCheck().catch(() => {});
    }, 2500);


})();
</script>
</body>
</html>
